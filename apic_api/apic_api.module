<?php

/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-L30, 5725-Z22
 *
 * (C) Copyright IBM Corporation 2018, 2021
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

/**
 * @file
 *
 * IBM API Connect Integration
 *
 * Adds the API node content type to Drupal for representing APIs from IBM APIC
 */

use Drupal\apic_api\Api;
use Drupal\apic_app\Application;
use Drupal\Component\Utility\Html;
use Drupal\Core\Access\AccessResultAllowed;
use Drupal\Core\Access\AccessResultForbidden;
use Drupal\Core\Access\AccessResultNeutral;
use Drupal\Core\Database\Database;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Link;
use Drupal\Core\Session\AccountInterface;
use Drupal\Core\Url;
use Drupal\node\Entity\Node;
use Drupal\node\NodeInterface;
use Drupal\product\Product;
use Drupal\user\Entity\User;
use Symfony\Component\HttpFoundation\RedirectResponse;

/* Permissions that can be granted
 * Note that we also use permissions defined in product.module
 */
define('EDIT_ANY_API_CONTENT_GRANT', 1);

/* Return the permission strings so that they can be displayed in the ACL log
 * Most of these come from the product module
 *
 * @param gid
 * @return string
 */
function api_permission_value($gid) {
  switch ($gid) {
    case EDIT_ANY_API_CONTENT_GRANT:
      return 'EDIT_ANY_API_CONTENT_GRANT';
    case PUBLIC_PRODUCT_GRANT:
      return 'PUBLIC_PRODUCT_GRANT';
    case AUTHENTICATED_PRODUCT_GRANT:
      return 'AUTHENTICATED_PRODUCT_GRANT';
    case SUBSCRIBED_TO_PRODUCT_GRANT:
      return 'SUBSCRIBED_TO_PRODUCT_GRANT';
    case ORG_PRODUCT_GRANT:
      return 'ORG_PRODUCT_GRANT';
    case TAG_PRODUCT_GRANT:
      return 'TAG_PRODUCT_GRANT';
    default:
      return 'Permission Value Not Known';
  }
}

/**
 * Implements hook_node_access_records().
 *
 * For API nodes, create a list of grants for the node based on the
 * products to which the API belongs
 *
 * @param $node
 *
 * @return array
 *
 * Note: hook is called when rebuilding permissions
 */
function apic_api_node_access_records($node) {

  ibm_apim_entry_trace(__CLASS__ . '::' . __FUNCTION__, NULL);

  $config = \Drupal::config('ibm_apim.settings');
  $aclDebug = (boolean) $config->get('acl_debug');

  $type = is_string($node) ? $node : $node->getType();
  $grants = [];
  $uniqueGrants = [];

  // Only build permissions for API nodes
  if ($type === 'api') {

    // Create a grant for 'edit any api content'
    $grants[] = [
      'realm' => 'api',
      'gid' => EDIT_ANY_API_CONTENT_GRANT,
      'grant_view' => 1,
      'grant_update' => 0,
      'grant_delete' => 0,
      'priority' => 0,
    ];

    $apiRef = $node->apic_ref->value;
    if ($apiRef) {
      // find the list of products to which this api belongs
      // apiref will be a string like: 'maths:1.0.0'
      // product_apis_value will be the same string
      $options = ['target' => 'default'];
      $query = Database::getConnection($options['target'])
        ->query("SELECT entity_id FROM {node__product_apis} WHERE product_apis_value LIKE '%" . $apiRef . "%'", [], $options);
      $prods = $query->fetchAll();


      // Now go through and create grants based on each of the products, using the
      // same scheme as in product_node_access_records (the logic is that if a user
      // can access any of the products which contain this API, they can view the API)
      foreach ($prods as $prod) {
        // Pick up all of the data we need.  Left Joins are used for tables where
        // there may not be an entry (e.g. if tags or orgs are not defined)
        $query = Database::getConnection($options['target'])->query('SELECT pub.product_visibility_public_value AS product_visibility_public_value, auth.product_visibility_authenticated_value AS product_visibility_authenticated_value
, org.product_visibility_custom_orgs_value AS product_visibility_custom_orgs_value, tags.product_visibility_custom_tags_value AS product_visibility_custom_tags_value, view.product_view_enabled_value AS product_view_enabled_value, prref.apic_ref_value AS apic_ref_value, state.product_state_value AS product_state_value, url.apic_url_value AS apic_url_value
FROM
node__product_visibility_public pub
INNER JOIN node__product_visibility_authenticated auth ON pub.entity_id = auth.entity_id
LEFT JOIN node__product_visibility_custom_orgs org ON pub.entity_id = org.entity_id
LEFT JOIN node__product_visibility_custom_tags tags ON pub.entity_id = tags.entity_id
LEFT JOIN node__apic_ref prref ON pub.entity_id = prref.entity_id
INNER JOIN node__product_view_enabled view ON pub.entity_id = view.entity_id
INNER JOIN node__product_state state ON prref.entity_id = state.entity_id
INNER JOIN node__apic_url url ON prref.entity_id = state.entity_id
WHERE  (pub.entity_id = ' . $prod->entity_id . ')', [], $options);

        $results = $query->fetchAll();

        // This is just too much debug; enable for special cases only
        //        if ($aclDebug === TRUE) {
        //          \Drupal::logger('apic_api')->debug('API %title searching for product %id: %results', [
        //            '%title' => var_export($node->getTitle(), TRUE),
        //            '%id' => $prod->entity_id,
        //            '%results' => var_export($results, TRUE),
        //          ]);
        //        }

        // The query will return multiple rows if there are multiple orgs or tags
        // or if there are multiple products with the same API
        // This causes duplication of the grants, which we will tidy up after
        foreach ($results as $row) {
          // Only create grants if the product is enabled
          if ((int) $row->product_view_enabled_value === 1) {
            // Create a grant for 'edit any product content'
            $grants[] = [
              'realm' => 'product',
              'gid' => EDIT_ANY_PRODUCT_CONTENT_GRANT,
              'grant_view' => 1,
              'grant_update' => 0,
              'grant_delete' => 0,
              'priority' => 0,
            ];
            
            if ((int) $row->product_visibility_public_value === 1) {

              // Create a grant for subscription base on the apic_url if the API's product is depcrecated 
              if ($row->product_state_value === 'deprecated' && isset($row->apic_url_value)) {
                $apic_url = str_replace('/', '_', $row->apic_url_value);
                $grants[] = [
                  'realm' => 'product_ref_' . $apic_url,
                  'gid' => SUBSCRIBED_TO_PRODUCT_GRANT,
                  'grant_view' => 1,
                  'grant_update' => 0,
                  'grant_delete' => 0,
                  'priority' => 0,
                ];
              }

              // Create a grant for public access if public is set and the API's product is not deprecated
              else {
                $grants[] = [
                  'realm' => 'product',
                  'gid' => PUBLIC_PRODUCT_GRANT,
                  'grant_view' => 1,
                  'grant_update' => 0,
                  'grant_delete' => 0,
                  'priority' => 0,
                ];
              }
            }
            // Create a grant for authenticated access if authenticated is set
            if ((int) $row->product_visibility_authenticated_value === 1) {
              $grants[] = [
                'realm' => 'product',
                'gid' => AUTHENTICATED_PRODUCT_GRANT,
                'grant_view' => 1,
                'grant_update' => 0,
                'grant_delete' => 0,
                'priority' => 0,
              ];
            }
            // Create a grant for subscription based on product reference
            if (isset($row->apic_ref_value)) {
              $grants[] = [
                'realm' => 'product_ref_' . $row->apic_ref_value,
                'gid' => SUBSCRIBED_TO_PRODUCT_GRANT,
                'grant_view' => 1,
                'grant_update' => 0,
                'grant_delete' => 0,
                'priority' => 0,
              ];
            }
            // Create a grant for organisations, as a separate realm based on the
            // org uuid.  If there are multiple orgs, then multiple grants each
            // with their own realm will be created
            if (isset($row->product_visibility_custom_orgs_value)) {
              $url = str_replace('/', '_', $row->product_visibility_custom_orgs_value);
              $grants[] = [
                'realm' => 'product_org_' . $url,
                'gid' => ORG_PRODUCT_GRANT,
                'grant_view' => 1,
                'grant_update' => 0,
                'grant_delete' => 0,
                'priority' => 0,
              ];
            }
            // Create a grant for tags, as a separate realm based on the
            // tag string.  If there are multiple tags, then multiple grants each
            // with their own realm will be created
            if (isset($row->product_visibility_custom_tags_value)) {
              $url = str_replace('/', '_', $row->product_visibility_custom_tags_value);
              $grants[] = [
                'realm' => 'product_tag_' . $url,
                'gid' => TAG_PRODUCT_GRANT,
                'grant_view' => 1,
                'grant_update' => 0,
                'grant_delete' => 0,
                'priority' => 0,
              ];
            }
          }
        }
      }
    }
    // Since multiple grants may have been created (due to the way the db_select
    // call returns multiple rows), we need to remove any that are duplicated
    // The code below does this by serialising each member of the grants array
    // and then using array_unique (which only works on strings) to ensure that
    // there are no duplicates
    $uniqueGrants = array_map('unserialize', array_unique(array_map('serialize', $grants)));
    if ($aclDebug === TRUE) {
      foreach ($uniqueGrants as $grant) {
        \Drupal::logger('ACLDEBUG')->debug('Realm: @realm granted: @grant', [
          '@realm' => $grant['realm'],
          '@grant' => api_permission_value($grant['gid']),
        ]);
      }
    }
  }
  ibm_apim_exit_trace(__CLASS__ . '::' . __FUNCTION__, $uniqueGrants);
  return $uniqueGrants;
}

/**
 * Implements hook_node_grants().
 *
 * Note that the vast majority of permissions for APIs are granted to the
 * user in the product.module, by design; access to APIs is based on access
 * to the products which use that API
 *
 * @param $account
 * @param $op
 *
 * @return array
 *
 * Note: hook is not called at all when admin logged in
 * Note: hook is called on every login, logout and page load
 */
function apic_api_node_grants($account, $op) {

  ibm_apim_entry_trace(__CLASS__ . '::' . __FUNCTION__, NULL);

  $config = \Drupal::config('ibm_apim.settings');
  $aclDebug = (boolean) $config->get('acl_debug');

  $grants = [];
  $userUtils = \Drupal::service('ibm_apim.user_utils');
  // If 'edit any api content' is set, grant EDIT_ANY_API_CONTENT_GRANT
  if ($userUtils->explicitUserAccess('edit any api content')) {
    $grants['api'] = [EDIT_ANY_API_CONTENT_GRANT];
    if ($aclDebug === TRUE) {
      foreach ($grants as $realm => $perms) {
        foreach ($perms as $grant) {
          \Drupal::logger('ACLDEBUG')->debug('Realm: @realm granted: @grant', [
            '@realm' => $realm,
            '@grant' => api_permission_value($grant),
          ]);
        }
      }
    }
  }
  ibm_apim_exit_trace(__CLASS__ . '::' . __FUNCTION__, $grants);
  return $grants;
}

/**
 * Implements hook_node_access().
 * This is checking if the specified api is returned from apim, if not it blocks access.
 *
 * @param \Drupal\node\NodeInterface $node
 * @param $operation
 * @param \Drupal\Core\Session\AccountInterface $account
 *
 * @return \Drupal\Core\Access\AccessResultAllowed|\Drupal\Core\Access\AccessResultForbidden|\Drupal\Core\Access\AccessResultNeutral
 */
function apic_api_node_access(NodeInterface $node, $operation, AccountInterface $account) {
  $type = $node->type;
  if ($type === 'api' && $operation === 'view') {
    $found = Api::checkAccess($node);
    // found so we're allowed to access this API
    if ($found === TRUE) {
      $access = new AccessResultAllowed();
    }
    else {
      $access = new AccessResultForbidden();
    }
  }
  else {
    $access = new AccessResultNeutral();
  }
  return $access;
}

/**
 * Need to use our custom content type templates
 *
 * @param $variables
 * @param $hook
 * @param $info
 */
function apic_api_preprocess(&$variables, $hook, &$info) {
  if ($hook === 'node') {
    $contentTypeToShow = $variables['node']->bundle();
    if ($contentTypeToShow === 'api') {
      ibm_apim_entry_trace(__FUNCTION__, NULL);
      //Load the view mode names.
      $allViewModes = \Drupal::service('entity_display.repository')->getViewModes('node');
      //View mode for this request.
      $viewModeToUse = $variables['view_mode'];
      //Is the view mode defined for nodes?
      if (array_key_exists($viewModeToUse, $allViewModes)) {
        //Is there a template file for the view modes in the module?
        if ($viewModeToUse === 'full') {
          $templateFileName = 'node--' . $contentTypeToShow;
        }
        else {
          $templateFileName = 'node--' . $contentTypeToShow . '--' . $viewModeToUse;
        }
        $themeName = \Drupal::theme()->getActiveTheme()->getName();
        $themePath = \Drupal::theme()->getActiveTheme()->getPath();
        if (file_exists($themePath . '/templates/node/' . $templateFileName . '.html.twig')) {
          $info['theme path'] = drupal_get_path('theme', $themeName);
          $info['path'] = drupal_get_path('theme', $themeName) . '/templates/node';
          $info['template'] = $templateFileName;
        }
        elseif (file_exists($themePath . '/templates/' . $templateFileName . '.html.twig')) {
          $info['theme path'] = drupal_get_path('theme', $themeName);
          $info['path'] = drupal_get_path('theme', $themeName) . '/templates';
          $info['template'] = $templateFileName;
        }
        else {
          $templateFilePath = drupal_get_path('module', 'apic_api') . '/templates/' . $templateFileName . '.html.twig';
          if (file_exists($templateFilePath)) {
            $info['theme path'] = drupal_get_path('module', 'apic_api');
            $info['path'] = drupal_get_path('module', 'apic_api') . '/templates';
            $info['template'] = $templateFileName;
          }
        }
      }
      ibm_apim_exit_trace(__FUNCTION__, NULL);
    }
  }
}

/**
 * @param $variables
 *
 * @return void
 * @throws \Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException
 * @throws \Drupal\Component\Plugin\Exception\PluginNotFoundException
 */
function apic_api_preprocess_node(&$variables): void {
  if ($variables['node']->getType() === 'api') {
    ibm_apim_entry_trace(__FUNCTION__, NULL);
    // get global settings first
    $config = \Drupal::config('ibm_apim.settings');
    $ibmApimShowPlaceholderImages = (boolean) $config->get('show_placeholder_images');
    $renderApiSchemaView = (boolean) $config->get('render_api_schema_view');
    $api_max_depth = $config->get('api_max_depth');
    if ($api_max_depth === null || !is_int($api_max_depth) || $api_max_depth < 2 || $api_max_depth > 25) {
      $api_max_depth = 9;
    }
    $variables['apiMaxDepth'] = $api_max_depth;
    if ($ibmApimShowPlaceholderImages === NULL) {
      $ibmApimShowPlaceholderImages = TRUE;
    }
    $variables['showPlaceholders'] = $ibmApimShowPlaceholderImages;
    if ($ibmApimShowPlaceholderImages) {
      $rawImage = Api::getRandomImageName($variables['node']->getTitle());
      $variables['placeholderUrl'] = base_path() . drupal_get_path('module', 'apic_api') . '/images/' . $rawImage;
    }
    else {
      $variables['placeholderUrl'] = NULL;
    }
    $ibmApimShowVersions = (boolean) $config->get('show_versions');
    if ($ibmApimShowVersions === NULL) {
      $ibmApimShowVersions = TRUE;
    }
    $variables['showVersions'] = $ibmApimShowVersions;

    // custom fields
    $viewMode = $variables['view_mode'];
    if ($viewMode === 'full') {
      $viewMode = 'default';
    }
    $diff = [];
    $entityView = \Drupal::entityTypeManager()->getStorage('entity_view_display')->load('node.api.' . $viewMode);
    if ($entityView !== NULL) {
      $components = $entityView->getComponents();
      $fieldList = array_keys($components);
      $coreFields = [
        'title',
        'vid',
        'status',
        'nid',
        'revision_log',
        'created',
        'links',
        'addtoany',
        'uid',
        'comment',
      ];
      $ibmFields = Api::getIBMFields();
      $merged = array_merge($coreFields, $ibmFields);
      $diff = array_diff($fieldList, $merged);
    }
    $variables['custom_fields'] = $diff;

    if ($variables['view_mode'] === 'full') {
      $showCorsWarnings = (boolean) $config->get('show_cors_warnings');
      $soapSwaggerDownload = (boolean) $config->get('soap_swagger_download');
      $soapCodeSnippets = (boolean) $config->get('soap_codesnippets');
      $optimiseOauthUX = (boolean) $config->get('optimise_oauth_ux');
      $showMTLSHeader = (boolean) $config->get('show_mtls_header');
      $certificateStripNewlines = (boolean) $config->get('certificate_strip_newlines');
      $certificateStripPrefix = (boolean) $config->get('certificate_strip_prefix');
      $codeSnippetLangs = [];
      $codeSnippets = $config->get('codesnippets');
      $firstEnabled = NULL;
      foreach ($codeSnippets as $lang => $enabled) {
        if ($enabled) {
          $codeSnippetLangs[] = $lang;
          if ($firstEnabled === NULL) {
            $firstEnabled = $lang;
          }
        }
      }
      $enableApiTest = (boolean) $config->get('enable_api_test');
      $applications = [];
      $defaultCodeSnippetLang = NULL;
      $currentUser = \Drupal::currentUser();
      if (!$currentUser->isAnonymous()) {
        $currentUser = User::load($currentUser->id());
      }
      if (isset($currentUser->codesnippet->value) && $currentUser->isAuthenticated()) {
        $defaultCodeSnippetLang = $currentUser->codesnippet->value;
      }

      $currentRoute = \Drupal::routeMatch()->getRouteName();
      if ($currentRoute !== NULL && $currentRoute === 'entity.node.canonical') {
        $prodNids = Product::getProductsContainingAPI($variables['node']->apic_ref->value);
        $apiNid = $variables['node']->id();
        if ($prodNids !== NULL && count($prodNids) === 1) {
          $prodNid = reset($prodNids);
          $path = Url::fromRoute('product.api', ['prodNode' => $prodNid, 'apiNode' => $apiNid])
            ->setAbsolute()
            ->toString();
        }
        else {
          $path = Url::fromRoute('product.select', ['apiNode' => $apiNid])->setAbsolute()->toString();
        }
        $response = new RedirectResponse($path);
        $response->send();
        return;
      }

      // if user's default lang not set or is not one of the enabled ones then default to first enabled
      if ($defaultCodeSnippetLang === NULL || empty($defaultCodeSnippetLang) || !in_array($defaultCodeSnippetLang, $codeSnippetLangs, FALSE)) {
        $defaultCodeSnippetLang = $firstEnabled;
      }
      if (!$currentUser->isAnonymous() && (int) $currentUser->id() !== 1 && \Drupal::service('module_handler')->moduleExists('apic_app')) {
        $apps = Application::listApplications();
        foreach ($apps as $app) {
          $application = Node::load($app);
          $credentials = [];
          if ($application !== NULL) {
            $appCredentials = $application->application_credentials_refs->referencedEntities();
            if ($appCredentials !== NULL && is_array($appCredentials)) {
              foreach ($appCredentials as $cred) {
                $credentials[] = [
                  'client_id' => $cred->client_id(),
                  'name' => $cred->name(),
                  'title' => $cred->title(),
                  'description' => $cred->summary(),
                ];
              }
              $redirectUris = [];
              foreach ($application->application_redirect_endpoints->getValue() as $arrayValue) {
                $redirectUris[] = $arrayValue['value'];
              }
              $applications[] = [
                'name' => $application->getTitle(),
                'summary' => $application->apic_summary->value,
                'redirectUri' => $redirectUris,
                'credentials' => $credentials,
              ];
            }
          }
        }
      }
      $customImage = $variables['node']->apic_image;
      $customImageString = NULL;
      if ($customImage !== NULL && !empty($customImage)) {
        $entity = $variables['node']->apic_image->entity;
        if ($entity !== NULL) {
          $customImageString = $entity->getFileUri();
        }
      }
      if ($customImageString !== NULL && !empty($customImageString)) {
        $apiImageUrl = $customImageString;
      }
      elseif ($ibmApimShowPlaceholderImages) {
        $apiImageUrl = Api::getPlaceholderImageURL($variables['node']->getTitle());
      }
      else {
        $apiImageUrl = NULL;
      }
      // get all of the custom fields and render them as per their view settings
      $infoSectionEntries = [];
      $renderer = \Drupal::service('renderer');
      $viewBuilder = \Drupal::entityTypeManager()->getViewBuilder('node');
      if (isset($variables['custom_fields']) && !empty($variables['custom_fields'])) {
        foreach ($variables['custom_fields'] as $customField) {
          if ($customField !== NULL && !empty($customField) && $entityView !== NULL) {
            $component = $entityView->getComponent($customField);
            if (isset($variables['node']->{$customField}, $variables['node']->{$customField}->value) && !empty($variables['node']->{$customField}->value)) {
              $field = $variables['node']->{$customField};
              $fieldRenderable = $viewBuilder->viewField($field, $component);
              if ($fieldRenderable !== NULL && !empty($fieldRenderable)) {
                $html = $renderer->renderPlain($fieldRenderable);
                $fieldConfig = \Drupal::entityTypeManager()
                  ->getStorage('field_config')
                  ->load('node.api.' . $customField);
                if ($fieldConfig !== NULL) {
                  $infoSectionEntries[] = [
                    'class' => $fieldConfig->get('label'),
                    'html' => $html,
                    'location' => 'OVERVIEW',
                  ];
                }
              }
            }
          }
        }
      }
      // add tags and other core drupal fields
      foreach ([
                 'apic_attachments',
                 'apic_tags',
                 'links',
                 'addtoany',
               ] as $fieldName) {
        $apicComponent = $entityView->getComponent($fieldName);
        if (isset($variables['node']->{$fieldName}) && $field = $variables['node']->{$fieldName}) {
          $fieldRenderable = $viewBuilder->viewField($field, $apicComponent);
          if (!empty($fieldRenderable) && count($fieldRenderable)) {
            $html = $renderer->renderPlain($fieldRenderable);
            $fieldConfig = \Drupal::entityTypeManager()->getStorage('field_config')->load('node.api.' . $fieldName);
            $location = 'OVERVIEW';
            $infoSectionEntries[] = [
              'class' => $fieldConfig->get('label') . ' ' . $fieldName,
              'html' => $html,
              'location' => $location,
            ];
          }
        }
      }
      // forum link
      $moduleHandler = \Drupal::service('module_handler');
      if ($moduleHandler->moduleExists('forum')) {
        $config = \Drupal::config('ibm_apim.settings');
        $forumLinksEnabled = (boolean) $config->get('autocreate_apiforum');
        if ($forumLinksEnabled === TRUE) {
          $cleanForumName = \Drupal::service('apic_api.taxonomy')
            ->sanitise_api_name(html_entity_decode($variables['node']->getTitle(), ENT_QUOTES));
          $forumID = taxonomy_term_load_multiple_by_name($cleanForumName, 'forums');
          if (!empty($forumID)) {
            reset($forumID);
            $firstKey = key($forumID);
            $link = Link::fromTextAndUrl(t('Discuss this API in the forum'), Url::fromRoute('forum.page', ['taxonomy_term' => $forumID[$firstKey]->tid->value]));
            $html = '<label class="forumLabel">' . t('Support') . '</label><div class="forumLink">' . $link->toString() . '</div>';
            $infoSectionEntries[] = [
              'class' => 'forum',
              'html' => $html,
              'location' => 'OVERVIEW',
            ];
          }
        }
      }

      $docPages = Api::getLinkedPages($variables['node']->id());
      $variables['docpages'] = $docPages;

      $utils = \Drupal::service('ibm_apim.utils');

      $variables['#attached']['library'][] = 'apic_api/explorer';
      $variables['#attached']['drupalSettings']['api']['explorer']['apis'] = [unserialize($variables['node']->api_swagger->value, ['allowed_classes' => FALSE])];
      $encodedSwagger = $variables['node']->api_encodedswagger->value;
      if ($encodedSwagger !== NULL && !empty($encodedSwagger)) {
        $variables['#attached']['drupalSettings']['api']['explorer']['encodedApis'] = [$encodedSwagger];
      }
      $variables['#attached']['drupalSettings']['api']['explorer']['apps'] = $applications;
      $variables['#attached']['drupalSettings']['api']['explorer']['options'] = [
        'showApiVersion' => $ibmApimShowVersions,
        'showCorsWarnings' => $showCorsWarnings,
        'showSoapSwaggerDownload' => $soapSwaggerDownload,
        'optimiseOauthUX' => $optimiseOauthUX,
        'showMTLSHeader' => $showMTLSHeader,
        'certificateStripPrefix' => $certificateStripPrefix,
        'certificateStripNewlines' => $certificateStripNewlines,
        'showSoapCodeSnippets' => $soapCodeSnippets,
        'languages' => $codeSnippetLangs,
        'defaultLanguage' => $defaultCodeSnippetLang,
        'tryIt' => $enableApiTest,
        'apiMaxDepth' => $variables['apiMaxDepth'],
        'onReady' => 'portalExplorerReady',
        'wsdlRetrieverURL' => Url::fromRoute('apic_api.retrievewsdl', ['api' => $variables['node']->apic_ref->value, 'endpoint' => 'REPLACE_THIS_VALUE'])->setAbsolute()->toString(),
        'explorerDir' => base_path() . drupal_get_path('module', 'apic_api') . '/explorer/app/',
        'locale' => $utils->convert_lang_name(\Drupal::languageManager()->getCurrentLanguage()->getId()),
        'loggedIn' => !$currentUser->isAnonymous(),
        'loginLink' => Url::fromRoute('user.login', ['redirectTo' => Url::fromRoute('<current>')->getInternalPath()])->toString(),
        'isApicPortal' => TRUE,
        'apicPortalUserId' => $currentUser->id(),
        'apicPortalNewAppLink' => Url::fromRoute('apic_app.create', ['redirectTo' => Url::fromRoute('<current>')->getInternalPath()])->toString(),
      ];
      if ($infoSectionEntries !== NULL && !empty($infoSectionEntries)) {
        $variables['#attached']['drupalSettings']['api']['explorer']['options']['infoSectionEntries'] = [$infoSectionEntries];
      }
      if ($docPages !== NULL && !empty($docPages)) {
        $variables['#attached']['drupalSettings']['api']['explorer']['options']['documentationEntries'] = [$docPages];
      }
      if ($apiImageUrl !== NULL && $apiImageUrl !== '') {
        $variables['#attached']['drupalSettings']['api']['explorer']['options']['apiImageUrl'] = $apiImageUrl;
      }
      if ($renderApiSchemaView === TRUE) {
        $variables['#attached']['drupalSettings']['api']['explorer']['options']['renderSchemaView'] = TRUE;
      }
    } else if ($variables['view_mode'] === 'embedded') {
      $prodNode = \Drupal::routeMatch()->getRawParameter('prodNode');
      if (isset($prodNode)) {
        $variables['prodNode'] = $prodNode;
      }
    }
    ibm_apim_exit_trace(__FUNCTION__, NULL);
  }
}

/**
 * Implements hook_form_alter().
 *
 * @param array $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 * @param $form_id
 */
function apic_api_form_alter(array &$form, FormStateInterface $form_state, $form_id) {
  switch ($form_id) {
    // remove link to delete our content type
    case 'node_type_edit_form' :
      if (isset($form['type']['#default_value'], $form['actions']['delete']) && $form['type']['#default_value'] === 'api') {
        unset($form['actions']['delete']);
      }
      break;
    case 'node_api_edit_form':
      // if anyone has made our internal fields visible, then lets make them readonly
      $internal_field_list = Api::getIBMFields();
      foreach ($internal_field_list as $fieldName) {
        if ($fieldName !== 'apic_pathalias' && $fieldName !== 'apic_tags' && $fieldName !== 'apic_rating' && $fieldName !== 'apic_image' && $fieldName !== 'apic_attachments' && isset($form[$fieldName])) {
          $form[$fieldName]['#disabled'] = TRUE;
        }
      }
      break;
  }
}

/**
 * We need our module to run last for the user register form so we can remove any other fields
 * other modules might have added - such as the forum notifications.
 *
 * @param $implementations
 * @param $hook
 */
function apic_api_module_implements_alter(&$implementations, $hook) {
  if (($hook === 'form_alter' || $hook === 'menu_links_discovered_alter' || $hook === 'library_info_alter') && isset($implementations['api'])) {
    $group = $implementations['api'];
    unset($implementations['api']);
    $implementations['api'] = $group;
  }
}

/**
 *  Implements hook_menu_links_discovered_alter().
 *
 * @param $links
 */
function apic_api_menu_links_discovered_alter(&$links) {
  // remove link to delete our content type
  if (isset($links['entity.node_type.delete_form.api'])) {
    unset($links['entity.node_type.delete_form.api']);
  }
  // remove link to create content of our content type
  if (isset($links['node.add.api'])) {
    unset($links['node.add.api']);
  }
}

/**
 * Dynamically add to the api/explorer library since the name of the explorer main.js changes every build
 *
 * @param $libraries
 * @param $extension
 */
function apic_api_library_info_alter(&$libraries, $extension) {
  if (array_key_exists('explorer', $libraries) && file_exists(drupal_get_path('module', 'apic_api') . '/explorer/app/asset-manifest.json')) {
    $string = file_get_contents(drupal_get_path('module', 'apic_api') . '/explorer/app/asset-manifest.json');
    $json = json_decode($string, TRUE);
    if (isset($json['main.js']) && file_get_contents(drupal_get_path('module', 'apic_api') . '/explorer/app/' . $json['main.js'])) {
      $libraries['explorer']['js']['explorer/app/' . $json['main.js']] = [
        'weight' => -1,
        'minified' => TRUE,
        'preprocess' => FALSE,
      ];
    }
  }
  // modify the load order for the voting_widgets/fivestar library as it needs to be loaded before our explorer libraries
  if (array_key_exists('fivestar', $libraries)) {
    $libraries['fivestar']['js']['js/fivestars.js']['weight'] = -3;
  }
}

/**
 * @param array $build
 * @param \Drupal\node\NodeInterface $node
 * @param $display
 * @param $viewMode
 */
function apic_api_node_view(array &$build, NodeInterface $node, $display, $viewMode) {
  if ($viewMode === 'full' && $node->getType() === 'api') {
    $currentUser = \Drupal::currentUser();
    if (!$currentUser->isAnonymous() && (int) $currentUser->id() !== 1) {
      // cache this api per devorg
      $userUtils = \Drupal::service('ibm_apim.user_utils');
      $org = $userUtils->getCurrentConsumerOrg();
      $tags = ['consumerorg:' . Html::cleanCssIdentifier($org['url'])];
      $build['#cache']['tags'] = array_merge($build['#cache']['tags'], $tags);
    }
  }
}
