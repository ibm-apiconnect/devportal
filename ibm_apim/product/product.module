<?php
/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-L30, 5725-Z22
 *
 * (C) Copyright IBM Corporation 2015, 2021
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

/**
 * IBM API Connect Integration
 *
 * Adds the Product node content type to Drupal for representing Products from IBM APIC
 */

/**
 * Implements hook_node_info().
 *
 * @return array
 */
function product_node_info() {
  return array(
    'product' => array(
      'name' => t('Product'),
      'base' => 'product',
      'description' => t('A Product in IBM API Connect')
    )
  );
}

/**
 * Implements hook_help().
 *
 * @param $path
 * @param $arg
 * @return string
 */
function product_help($path, $arg) {
  switch ($path) {
    case 'admin/help#product' :
      $output = '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t("The Product module provides a new custom node type for use with IBM API Connect.") . '</p>';
      $output .= '<h3>' . t('Uses') . '</h3>';
      $output .= '<dl>';
      $output .= '<dt>' . t('Select a product') . '</dt>';
      $output .= '<dd>' . t("This module enables the user to see the different products available in IBM API Connect, showing the details and any rate limiting policy included in them.") . '</dd>';
      $output .= '</dl>';
      return $output;
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * @param $form
 * @param $form_state
 */
function product_form_product_node_form_alter(&$form, &$form_state) {
  // this function hides all our custom fields from the edit node form as they are all set explicitly
  $form['product_apimhostname']['#access'] = 0;
  $form['product_providerid']['#access'] = 0;
  $form['product_environmentid']['#access'] = 0;
  $form['product_id']['#access'] = 0;
  $form['product_name']['#access'] = 0;
  $form['product_ref']['#access'] = 0;
  $form['product_version']['#access'] = 0;
  $form['product_description']['#access'] = 0;
  $form['product_contact_name']['#access'] = 0;
  $form['product_contact_email']['#access'] = 0;
  $form['product_contact_url']['#access'] = 0;
  $form['product_license_name']['#access'] = 0;
  $form['product_license_url']['#access'] = 0;
  $form['product_terms_of_service']['#access'] = 0;
  $form['product_visibility']['#access'] = 0;
  $form['product_view_enabled']['#access'] = 0;
  $form['product_subscribe_enabled']['#access'] = 0;
  $form['product_visibility_public']['#access'] = 0;
  $form['product_visibility_authenticated']['#access'] = 0;
  $form['product_visibility_custom_orgs']['#access'] = 0;
  $form['product_visibility_custom_tags']['#access'] = 0;
  $form['product_plans']['#access'] = 0;
  $form['product_apis']['#access'] = 0;
  $form['product_url']['#access'] = 0;
  $form['product_state']['#access'] = 0;
  $form['product_data']['#access'] = 0;
  $form['title']['#access'] = 0;
}

/**
 * Implements hook_form().
 *
 * @param $node
 * @param $form_state
 * @return array
 */
function product_form($node, $form_state) {
  return node_content_form($node, $form_state);
}

/**
 * Implements hook_view().
 *
 * @param $node
 * @param $view_mode
 * @return mixed
 */
function product_view($node, $view_mode) {
  return $node;
}

/**
 * Implements hook_node_view().
 *
 * @param $node
 * @param $view_mode
 */
function product_node_view($node, $view_mode) {
}

function acl_log($data) {
  // Enable the next line to log grants as they are created and used
  // file_put_contents('/tmp/acl.log', $data. PHP_EOL. PHP_EOL, FILE_APPEND);

  // UNCOMMENT ABOVE LINE TO ENABLE THIS LOGGING - ALSO UNCOMMENT CALLS TO acl_log IN THIS FILE AND ALSO ../api/api.module
}

/* Permissions that can be granted */
define('EDIT_ANY_PRODUCT_CONTENT_GRANT', 1);
define('PUBLIC_PRODUCT_GRANT', 2);
define('AUTHENTICATED_PRODUCT_GRANT', 3);
define('SUBSCRIBED_TO_PRODUCT_GRANT', 4);
define('ORG_PRODUCT_GRANT', 5);
define('TAG_PRODUCT_GRANT', 6);

/**
 * Implements hook_node_access_records().
 *
 * For product nodes, create a list of grants for the node based on available
 * capabilities within the node configuration; where the capabilities are
 * specific to individual products, organisations or tags then use realm named
 * after product id, organisation or tag
 *
 * @param $node
 * @return array
 *
 * Note: hook is called when rebuilding permissions
 */
function product_node_access_records($node) {

  //acl_log('Enter: product_node_access_records');
  $type = is_string($node) ? $node : $node->type;
  $grants = array();
  // Only build permissions for product nodes
  if ($type == 'product') {
    //acl_log('Node: ' . $node->title);

    // only include published and deprecated products
    if (isset($node->product_state[$node->language][0]) && $node->product_state[$node->language][0]['value'] == "published") {
      // Only issue grants if product_view is enabled
      if (isset($node->product_view_enabled[$node->language][0]) && $node->product_view_enabled[$node->language][0]['value'] == 1) {
        // Create a grant for 'edit any product content' (will be set in hook_node_grants())
        $grants[] = array(
          'realm' => 'product',
          'gid' => EDIT_ANY_PRODUCT_CONTENT_GRANT,
          'grant_view' => 1,
          'grant_update' => 0,
          'grant_delete' => 0,
          'priority' => 0,
        );
        // Create a grant for public access if public is set
        if (isset($node->product_visibility_public[$node->language][0]['value']) && $node->product_visibility_public[$node->language][0]['value'] == 1) {
          $grants[] = array(
            'realm' => 'product',
            'gid' => PUBLIC_PRODUCT_GRANT,
            'grant_view' => 1,
            'grant_update' => 0,
            'grant_delete' => 0,
            'priority' => 0,
          );
        }
        // Create a grant for authenticated access if authenticated is set
        if (isset($node->product_visibility_authenticated[$node->language][0]['value']) && $node->product_visibility_authenticated[$node->language][0]['value'] == 1 && user_is_logged_in()) {
          $grants[] = array(
            'realm' => 'product',
            'gid' => AUTHENTICATED_PRODUCT_GRANT,
            'grant_view' => 1,
            'grant_update' => 0,
            'grant_delete' => 0,
            'priority' => 0,
          );
        }
        // Create a grant for all organisations (as separate realms) if org visibility is set
        if (isset($node->product_visibility_custom_orgs[$node->language])) {
          foreach ($node->product_visibility_custom_orgs[$node->language] as $customorg) {
            if (isset($customorg['value'])) {
              $grants[] = array(
                'realm' => 'product_org_' . $customorg['value'],
                'gid' => ORG_PRODUCT_GRANT,
                'grant_view' => 1,
                'grant_update' => 0,
                'grant_delete' => 0,
                'priority' => 0,
              );
            }
          }
        }
        // Create a grant for all tags (as separate realms) if tag visibility is set
        if (isset($node->product_visibility_custom_tags[$node->language])) {
          foreach ($node->product_visibility_custom_tags[$node->language] as $customtag) {
            if (isset($customtag['value'])) {
              $grants[] = array(
                'realm' => 'product_tag_' . $customtag['value'],
                'gid' => TAG_PRODUCT_GRANT,
                'grant_view' => 1,
                'grant_update' => 0,
                'grant_delete' => 0,
                'priority' => 0,
              );
            }
          }
        }
      }
    }
    // Create a grant for subscription to this node based on product reference
    if (isset($node->product_state[$node->language][0]) && $node->product_state[$node->language][0]['value'] == "deprecated") {
      $pref = $node->product_ref[$node->language][0]['value'];
      $grants[] = array(
        'realm' => 'product_ref_' . $pref,
        'gid' => SUBSCRIBED_TO_PRODUCT_GRANT,
        'grant_view' => 1,
        'grant_update' => 0,
        'grant_delete' => 0,
        'priority' => 0,
      );
    }

    //acl_log('Grants: ' . var_export($grants, TRUE));
  }
  //acl_log('Exit: product_node_access_records');
  return $grants;
}

/**
 * Implements hook_node_grants().
 *
 * @param $account
 * @param $op
 * @return array
 *
 * Note: hook is not called at all when admin logged in
 * Note: hook is called on every login, logout and page load
 */
function product_node_grants($account, $op) {

  /*acl_log('Enter: product_node_grants');
  if (isset($account->name)) {
    acl_log('Account: ' . $account->name);
  }
  else {
    acl_log('Account: anonymous');
  }*/

  $grants = array();
  $grants['product'] = array();

  // Grant everyone PUBLIC_PRODUCT_GRANT
  array_push($grants['product'], PUBLIC_PRODUCT_GRANT);

  // If logged in, grant AUTHENTICATED_PRODUCT_GRANT
  if (user_is_logged_in()) {
    array_push($grants['product'], AUTHENTICATED_PRODUCT_GRANT);
  }

  // If 'edit any product content' is set, grant EDIT_ANY_PRODUCT_CONTENT_GRANT
  if (ibm_apim_explicit_user_access('edit any product content')) {
    array_push($grants['product'], EDIT_ANY_PRODUCT_CONTENT_GRANT);
  }

  // Subscriptions and tags are only set for orgs, so only run that code
  // if the user is in a development organisation
  $myorg = ibm_apim_get_current_developer_org();
  if (isset($myorg['id'])) {

    // Grant ORG_PRODUCT_GRANT for a realm representing the user's org
    $orgid = $myorg['id'];
    $grants['product_org_' . $orgid] = array(ORG_PRODUCT_GRANT);

    // Check for subscriptions, if they exist add a SUBSCRIBED_TO_PRODUCT_GRANT
    // for each subscription to a product-specific realm
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', 'application')
      ->fieldCondition('application_orgid', 'value', $orgid);
    // Must use the DANGEROUS_ACCESS_CHECK_OPT_OUT to avoid recursion
    // (node access system is invoked when executing an EntityFieldQuery)
    $appresults = $query->addTag('DANGEROUS_ACCESS_CHECK_OPT_OUT')->execute();
    if (isset($appresults['node'])) {
      $nids = array();
      foreach ($appresults['node'] as $item) {
        $nids[] = $item->nid;
        $query = db_query("SELECT application_subscriptions_value FROM {field_data_application_subscriptions} WHERE entity_id = $item->nid");
        $subresults = $query->fetchAll();
        foreach ($subresults as $key => $subresult) {
          $subs = unserialize($subresults[$key]->application_subscriptions_value);
          if (is_array($subs)) {
            foreach ($subs as $sub) {
              if (isset($sub['product'])) {
                $pref = $sub['product'];
                $grants['product_ref_' . $pref] = array(SUBSCRIBED_TO_PRODUCT_GRANT);
              }
            }
          }
        }
      }
    }

    // Check for custom tags, if they exist add a TAG_PRODUCT_GRANT for
    // each tag in a tag-specific realm
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', 'devorg')
      ->fieldCondition('devorg_id', 'value', $orgid);
    // Must use the DANGEROUS_ACCESS_CHECK_OPT_OUT to avoid recursion
    // (node access system is invoked when executing an EntityFieldQuery)
    $devorgresults = $query->addTag('DANGEROUS_ACCESS_CHECK_OPT_OUT')->execute();
    if (isset($devorgresults['node'])) {
      $first = array_shift($devorgresults['node']);
      $devorgnid = $first->nid;
      if (!empty($devorgnid)) {
        $query = db_query("SELECT devorg_tags_value FROM {field_data_devorg_tags} WHERE entity_id = $devorgnid");
        $doresults = $query->fetchAll();
        foreach ($doresults as $devorg_tag) {
          $tags[] = $devorg_tag->devorg_tags_value;
        }
        if (isset($tags) && is_array($tags) && count($tags) > 0) {
          foreach ($tags as $customtag) {
            if (isset($customtag)) {
              $grants['product_tag_' . $customtag] = array(TAG_PRODUCT_GRANT);
            }
          }
        }
      }
    }
  }

  /*if (isset($account->name)) {
    acl_log('Grants: ' . var_export($grants, TRUE));
  }
  acl_log('Exit: product_node_grants');*/
  return $grants;
}

/**
 * Implements hook_node_access().
 * This is checking if the specified product is accessible to the current user, if not it blocks access.
 *
 * @param $node
 * @param $op
 * @param $account
 * @return int
 */
function product_node_access($node, $op, $account) {
  $type = is_string($node) ? $node : $node->type;
  if ($type == 'product' && $op == 'view') {
    if (product_check_product_access($node)) {
      return NODE_ACCESS_ALLOW;
    }
    else {
      return NODE_ACCESS_DENY;
    }
  }
  else {
    return NODE_ACCESS_IGNORE;
  }
}

/**
 * Implements hook_menu().
 *
 * @return array
 */
function product_menu() {
  // the use of _product_path_param_to_arg in some of these menu entries is to avoid a menu_translate error message
  // we cant use a proper load method since we need both args to return the proper object
  $items = array();
  $items['product'] = array(
    'title' => 'API Products',
    'page callback' => 'product_collection_callback',
    'menu_name' => 'main-menu',
    'weight' => 4,
    'description' => 'API Products',
    'access callback' => TRUE
  );
  $items['product/%_product_path_param_to_arg'] = array(
    'title' => 'View',
    'page callback' => 'product_collection_callback',
    'page arguments' => array(1),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK
  );
  $items['product/select/%'] = array(
    'title' => 'Select Product',
    'page callback' => 'product_multiple_select_api',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK
  );
  $items['productapi/%/%'] = array(
    'title' => 'View API',
    'page callback' => 'product_view_api',
    'page arguments' => array(1, 2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK
  );
  return $items;
}

/**
 * Implements hook_token_info().
 *
 * @return array
 */
function product_token_info() {
  $type = array(
    'name' => t('Product tokens'),
    'description' => t('Product tokens'),
    'needs-data' => 'product',
  );
  $product['product_id'] = array(
    'name' => t("Product ID"),
    'description' => t("The ID of the product."),
  );
  $product['product_nid'] = array(
    'name' => t("Product node ID"),
    'description' => t('The node ID of the product.'),
  );
  $product['product_name'] = array(
    'name' => t("Product name"),
    'description' => t('The name of the product.'),
  );
  $product['product_version'] = array(
    'name' => t("Product version"),
    'description' => t('The product version.'),
  );
  $product['product_ref'] = array(
    'name' => t("Product reference"),
    'description' => t('The product reference (name:version).'),
  );
  $product['product_description'] = array(
    'name' => t("Product description"),
    'description' => t('The product description.'),
  );
  $product['product_contact_name'] = array(
    'name' => t("Product contact name"),
    'description' => t('The contact name for the product.'),
  );
  $product['product_contact_email'] = array(
    'name' => t("Product contact email address"),
    'description' => t('The contact email address for the product.'),
  );
  $product['product_contact_url'] = array(
    'name' => t("Product contact URL"),
    'description' => t('The contact URL for the product.'),
  );

  return array(
    'types' => array('product' => $type),
    'tokens' => array('product' => $product),
  );
}

/**
 * Implements hook_tokens().
 *
 * @param $type
 * @param null $object
 * @param array $options
 * @return array
 */
function product_tokens($type, $object = NULL, $options = array()) {
  $tokens = array();
  if ($type == 'product' || $type == 'all') {
    $tokens = array(
      'product_id' => $object['product_id'],
      'product_nid' => $object['product_nid'],
      'product_name' => $object['product_name'],
      'product_version' => $object['product_version'],
      'product_ref' => $object['product_ref'],
      'product_description' => $object['product_description'],
      'product_contact_name' => $object['product_contact_name'],
      'product_contact_email' => $object['product_contact_email'],
      'product_contact_url' => $object['product_contact_url'],
    );
    return $tokens;
  }
}

/**
 * Menu callback;
 * if a specific product has been requested will display that as full viewmode,
 * else it will show teaser viewmode for all available products
 *
 * @param null $productid
 * @return array|void
 * @throws \Exception
 */
function product_collection_callback($productid = NULL) {
  $build = array();
  $host_pieces = _ibm_apim_parse_apim_host();
  if (empty($host_pieces)) {
    drupal_set_message(t('IBM APIC Module is not correctly configured. Specify a valid hostname and try again.'), 'error');
    return NULL;
  }
  $limit = variable_get('default_nodes_main', 10);

  // set so that drupal_set_message actually works
  drupal_page_is_cacheable(FALSE);

  if ($productid == NULL) {
    $nids = product_list_products();
    if (!empty($nids)) {
      $nodes = node_load_multiple($nids);
      $nids = [];
      // Only include nodes that are set as published
      foreach ($nodes as $node) {
        if (($node->product_state[$node->language][0]['value'] == "published" || $node->product_state[$node->language][0]['value'] == "deprecated") && $node->product_view_enabled[$node->language][0]['value'] == 1 ) {
          array_push($nids, $node->nid);
        }
      }

      // handle paging
      $page = pager_find_page();
      $total = count($nids);
      $offset = $limit * $page;
      $chunk = array_slice($nids, $offset, $limit);
      pager_default_initialize($total, $limit);
      $finalnodes = node_load_multiple($chunk);

      if ($finalnodes) {
        $build = array(
          'content' => node_view_multiple($finalnodes),
          'pager' => array('#markup' => theme('pager'), '#weight' => $limit)
        );
      }
      else {
        drupal_set_message(t('No products have been found.'), 'warning');
      }
    }
    else {
      drupal_set_message(t('No products have been found.'), 'warning');
    }

  }
  else {
    // specific product
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', 'product')
      ->propertyCondition('status', 1)
      ->fieldCondition('product_id', 'value', check_plain($productid));
    $results = $query->execute();
    if (isset($results['node'])) {
      $first = array_shift($results['node']);
      $nid = $first->nid;
      $node = node_load($nid);
      if (product_check_product_access($node)) {
        drupal_goto('node/' . $node->nid);
      }
      else {
        drupal_set_message(t('The specified product could not be found or you do not have permission to access it.'), 'error');
      }
    }
    else {
      drupal_set_message(t('The specified product could not be found or you do not have permission to access it.'), 'error');
    }
  }
  return $build;
}

/**
 * Method used to get a specific API in the context of a specific product
 * @param $productid
 * @param $apiref
 */
function product_view_api($productid, $apiref) {
  $apim_session = &_ibm_apim_get_apim_session();
  // set so that drupal_set_message actually works
  drupal_page_is_cacheable(FALSE);

  $apiref = ibm_apim_base64_url_decode($apiref);

  $productid = check_plain($productid);
  $productnode = node_load($productid);
  $found = FALSE;
  if (product_check_product_access($productnode)) {
    // check this product actually includes the specified API
    if (isset($productnode->product_apis[$productnode->language][0]['value'])) {
      $prodrefs = unserialize($productnode->product_apis[$productnode->language][0]['value']);
      foreach ($prodrefs as $prodref) {
        if ($prodref['name'] == $apiref) {
          $found = TRUE;
        }
      }
    }
    if ($found == TRUE) {
      $query = new EntityFieldQuery();
      $query->entityCondition('entity_type', 'node')
        ->entityCondition('bundle', 'api')
        ->propertyCondition('status', 1)
        ->fieldCondition('api_ref', 'value', $apiref);

      $results = $query->execute();

      if (isset($results['node'])) {
        $first = array_shift($results['node']);
        $nid = $first->nid;
        $node = node_load($nid);
        // set product id in the session so we can access it in the api display code
        $apim_session['productid'] = $productid;
        drupal_goto('node/' . $node->nid);
      }
      else {
        drupal_set_message(t('The specified API could not be found or you do not have permission to access it.'), 'error');
        drupal_goto('node/' . $productid);
      }
    }
    else {
      drupal_set_message(t('The specified API could not be found or you do not have permission to access it.'), 'error');
      drupal_goto('node/' . $productid);
    }
  }
  else {
    drupal_set_message(t('The specified product could not be found or you do not have permission to access it.'), 'error');
    drupal_goto('node/' . $productid);
  }
}

/**
 * Method used to get a specific API in the context of a specific product
 * @param $apinid
 * @return array
 * @throws \Exception
 */
function product_multiple_select_api($apinid) {
  $build = array();
  $apim_session = &_ibm_apim_get_apim_session();
  // set so that drupal_set_message actually works
  drupal_page_is_cacheable(FALSE);

  if (in_array($apinid, api_list_apis())) {

    $api = node_load($apinid);
    if (isset($api)) {
      $allowed_products = product_list_products();
      $prod_nids = array();
      $query = new EntityFieldQuery();
      $query->entityCondition('entity_type', 'node')
        ->entityCondition('bundle', 'product')
        ->fieldCondition('product_apis', 'value', $api->api_ref[$api->language][0]['value'], 'CONTAINS');
      $results = $query->execute();
      if (isset($results['node'])) {
        foreach ($results['node'] as $item) {
          if (in_array($item->nid, $allowed_products)) {
            $prod_nids[] = $item->nid;
          }
        }
      }
      $limit = variable_get('default_nodes_main', 10);

      // handle paging
      $page = pager_find_page();
      $total = count($prod_nids);
      $offset = $limit * $page;
      $chunk = array_slice($prod_nids, $offset, $limit);
      pager_default_initialize($total, $limit);

      // Only include nodes that are set as published
      $finalnodes = array();
      $allnodes = node_load_multiple($chunk);
      foreach ($allnodes as $node) {
        if ($node->product_state[$node->language][0]['value'] == "published") {
          array_push($finalnodes, $node);
        }
      }

      if ($finalnodes) {
        $build = array(
          'content' => node_view_multiple($finalnodes),
          'pager' => array('#markup' => theme('pager'), '#weight' => $limit)
        );
        array_unshift($build, array(
          '#type' => 'markup',
          '#markup' => '<h4>' . t('This API is in more than one Product. Select one from the list below.') . '</h4>',
        ));
      }
      else {
        drupal_set_message(t('No products containing this API have been found.'), 'warning');
      }
    }
    else {
      drupal_set_message(t('No API found.'), 'warning');
    }
  }
  else {
    drupal_set_message(t('Access denied.'), 'warning');
  }

  return $build;
}

/**
 * Creates or updates an existing node. Returns true if a new node was
 * created or false if an existing one was updated.
 * @param $product
 * @param $event
 * @return bool
 */
function product_createOrUpdateProduct($product, $event) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'product')
    ->fieldCondition('product_ref', 'value', $product['document']['info']['name'] . ':' . $product['document']['info']['version']);

  $results = $query->execute();

  if (isset($results['node'])) {
    $first = array_shift($results['node']);
    $nid = $first->nid;
    $node = node_load($nid);
    //retrieve currently associated apis
    $apis = product_get_apis($nid);
    _product_updateExistingProductNode($node, $product, $event);
    //retrieve new set of currently associated apic_ssh_key_status
    $napis = product_get_apis($nid);
    //check whether any of the apis in $apis is no longer associated
    foreach ($apis as $apinid) {
      $found = FALSE;
      foreach ($napis as $napinid) {
        if ($apinid == $napinid) {
          $found = TRUE;
        }
      }
      //if not found API is potentially orphaned, so check if it is associated with any other products
      if (!$found) {
        $api = node_load($apinid, NULL, TRUE);
        //Check this api is not still referenced by a product
        $query = new EntityFieldQuery();
        $query->entityCondition('entity_type', 'node')
          ->entityCondition('bundle', 'product')
          ->fieldCondition('product_apis', 'value', $api->api_ref[$api->language][0]['value'], 'CONTAINS');
        $results = $query->execute();
        if (isset($results['node'])) {
          $prod_nids = array_keys($results['node']);
          $product_ids = array();
          if (is_array($prod_nids) && count($prod_nids) > 0) {
            foreach ($prod_nids as $prod_nid) {
              $product = node_load($prod_nid);
              $product_id = $product->product_ref[$product->language][0]['value'];
              array_push($product_ids, $product_id);
            }
          }
          if (is_array($product_ids) && count($product_ids) > 0) {
            $prodids = implode(" ", $product_ids);
          }
          else {
            $prodids = implode(" ", $prod_nids);
          }
          drupal_set_message(t('Drush DeleteAPI NOT deleting API @api as it is referenced by the following product(s) @prods', array(
            '@api' => $api->api_ref[$api->language][0]['value'],
            '@prods' => $prodids
          )), 'warning');
        }
        else {
          api_deleteAPINode($nid, $event);
          drupal_set_message(t('Drush DeleteAPI deleted API @api', array('@api' => $api->api_ref[$api->language][0]['value'])), 'success');
        }
      }
    }
    $createdOrUpdated = FALSE;
  }
  else {
    // no existing node for this Product so create one
    _product_createNewProductNode($product, $event);
    $createdOrUpdated = TRUE;
  }
  return $createdOrUpdated;
}

/**
 * Create a new product node
 * @param $product
 * @return mixed
 * @throws \Exception
 */
function _product_createNewProductNode($product, $event = 'publish') {
  $hostvariable = variable_get('ibm_apim_host');
  $apim_session = &_ibm_apim_get_apim_session();
  $oldtags = NULL;
  $language_list = array_keys(locale_language_list('name', TRUE));

  if (isset($product) && isset($product['document']['info']) && isset($product['document']['info']['name']) && isset($product['document']['info']['version'])) {
    $xname = $product['document']['info']['name'];
    if (strlen($product['document']['info']['name'] . ':' . $product['document']['info']['version']) > 254) {
      // if product reference is too long then bomb out
      watchdog('_product_createNewProductNode', 'ERROR: The "name:version" for this product is greater than 254 characters: %name %version', array(
        '%name' => $product['document']['info']['name'],
        '%version' => $product['document']['info']['version']
      ), WATCHDOG_ERROR);
      return null;
    }
  }

  if (isset($xname)) {
    // find if there is an existing node for this API (maybe at old version)
    // using x-ibm-name from swagger doc
    // if so then clone it and base new node on that.
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', 'product')
      ->fieldCondition('product_name', 'value', $xname)
      ->propertyOrderBy('nid', 'ASC');
    $results = $query->execute();
  }

  if (isset($results['node'])) {
    $first = array_shift($results['node']);
    $nid = $first->nid;
    $node = node_load($nid);
  }
  if (isset($node) && isset($node->nid)) {
    if (isset($node->field_producttags[$node->language]) && is_array($node->field_producttags[$node->language])) {
      foreach ($node->field_producttags[$node->language] as $tag) {
        if (isset($tag['tid'])) {
          $oldtags[] = $tag['tid'];
        }
      }
    }
    $node->field_producttags[$node->language] = array();
    // unset version and node ids
    // this is so that node_save creates a new node rather than updating the existing one
    unset($node->nid);
    unset($node->vid);
    unset($node->status);
    unset($node->path);
    unset($node->product_apimhostname[$node->language]);
    unset($node->product_providerid[$node->language]);
    unset($node->product_environmentid[$node->language]);
    unset($node->product_id[$node->language]);
    unset($node->product_name[$node->language]);
    unset($node->product_ref[$node->language]);
    unset($node->product_version[$node->language]);
    unset($node->product_description[$node->language]);
    unset($node->product_contact_name[$node->language]);
    unset($node->product_contact_email[$node->language]);
    unset($node->product_contact_url[$node->language]);
    unset($node->product_license_name[$node->language]);
    unset($node->product_license_url[$node->language]);
    unset($node->product_terms_of_service[$node->language]);
    unset($node->product_visibility[$node->language]);
    unset($node->product_view_enabled[$node->language]);
    unset($node->product_subscribe_enabled[$node->language]);
    unset($node->product_visibility_public[$node->language]);
    unset($node->product_visibility_authenticated[$node->language]);
    unset($node->product_visibility_custom_orgs[$node->language]);
    unset($node->product_visibility_custom_tags[$node->language]);
    unset($node->product_url[$node->language]);
    unset($node->product_state[$node->language]);
    unset($node->product_plans[$node->language]);
    unset($node->product_apis[$node->language]);
    unset($node->product_data[$node->language]);
  }
  else {
    $node = new stdClass();
    $node->type = "product";
    node_object_prepare($node); // Sets some defaults. Invokes hook_prepare() and hook_node_prepare().
  }

  if (isset($product['document']['info']['x-ibm-languages']['title']) && !empty($product['document']['info']['x-ibm-languages']['title'])) {
    foreach ($product['document']['info']['x-ibm-languages']['title'] as $lang => $lang_array) {
      $lang = _ibm_apim_convert_lang_name_to_drupal($lang);
      // if its one of our locales or the root of one of our locales
      foreach ($language_list as $lang_list_key => $lang_list_value) {
        if ($lang == $lang_list_key || $lang == substr($lang_list_key, 0, count($lang))) {
          $node->title_field[$lang][] = array(
            'value' => ibm_apim_truncate_string($product['document']['info']['x-ibm-languages']['title'][$lang]),
            'format' => 'plain_text'
          );
        }
      }
    }
  }

  $node->title = ibm_apim_truncate_string($product['document']['info']['title']);
  // if en wasn't in the x-ibm-languages list then assume it was the root level one
  if (!isset($product['document']['info']['x-ibm-languages']['title']) || !in_array('en', array_keys($product['document']['info']['x-ibm-languages']['title']))) {
    $node->title_field['en'][] = array(
      'value' => ibm_apim_truncate_string($product['document']['info']['title']),
      'format' => 'plain_text'
    );
    $node->title_field['und'][] = array(
      'value' => ibm_apim_truncate_string($product['document']['info']['title']),
      'format' => 'plain_text'
    );
  }

  $node->language = LANGUAGE_NONE;
  $node->uid = 1;
  $node->promote = 0;
  if (!module_exists('workbench_moderation')) {
    $node->status = 1;
  }

  $node->product_apimhostname[$node->language][] = array(
    'value' => $hostvariable,
    'format' => 'plain_text'
  );
  $node->product_providerid[$node->language][] = array(
    'value' => $apim_session['org'],
    'format' => 'plain_text'
  );
  $node->product_environmentid[$node->language][] = array(
    'value' => $apim_session['env'],
    'format' => 'plain_text'
  );
  $node->product_id[$node->language][] = array(
    'value' => $product['id'],
    'format' => 'plain_text'
  );
  $node->product_ref[$node->language][] = array(
    'value' => $product['document']['info']['name'] . ':' . $product['document']['info']['version'],
    'format' => 'plain_text'
  );
  $node->product_state[$node->language][] = array(
    'value' => mb_strtolower($product['state']),
    'format' => 'plain_text'
  );
  $node->product_name[$node->language][] = array(
    'value' => $product['document']['info']['name'],
    'format' => 'plain_text'
  );
  $node->product_version[$node->language][] = array(
    'value' => $product['document']['info']['version'],
    'format' => 'plain_text'
  );
  // ensure description is at least set to empty string
  if (!isset($product['document']['info']['description']) || empty($product['document']['info']['description'])) {
    $product['document']['info']['description'] = '';
  }

  if (isset($product['document']['info']['x-ibm-languages']['description']) && !empty($product['document']['info']['x-ibm-languages']['description'])) {
    foreach ($product['document']['info']['x-ibm-languages']['description'] as $lang => $lang_array) {
      $lang = _ibm_apim_convert_lang_name_to_drupal($lang);
      // if its one of our locales or the root of one of our locales
      foreach ($language_list as $lang_list_key => $lang_list_value) {
        if ($lang == $lang_list_key || $lang == substr($lang_list_key, 0, count($lang))) {
          if (!isset($product['document']['info']['x-ibm-languages']['description'][$lang]) || empty($product['document']['info']['x-ibm-languages']['description'][$lang])) {
            $product['document']['info']['x-ibm-languages']['description'][$lang] = '';
          }
          $node->product_description[$lang][] = array(
            'value' => $product['document']['info']['x-ibm-languages']['description'][$lang],
            'format' => 'plain_text'
          );
        }
      }
    }
    // if en wasn't in the x-ibm-languages list then assume it was the root level one
    if (!in_array('en', array_keys($product['document']['info']['x-ibm-languages']['description']))) {
      $node->product_description['en'][] = array(
        'value' => $product['document']['info']['description'],
        'format' => 'plain_text'
      );
    }
  }
  else {
    $node->product_description[$node->language][] = array(
      'value' => $product['document']['info']['description'],
      'format' => 'plain_text'
    );
  }
  if (!isset($product['document']['info']['contact'])) {
    $product['document']['info']['contact'] = array(
      'name' => "",
      'email' => "",
      'url' => ""
    );
  }
  if (!isset($product['document']['info']['contact']['name'])) {
    $product['document']['info']['contact']['name'] = "";
  }
  if (!isset($product['document']['info']['contact']['email'])) {
    $product['document']['info']['contact']['email'] = "";
  }
  if (!isset($product['document']['info']['contact']['url'])) {
    $product['document']['info']['contact']['url'] = "";
  }
  $node->product_contact_name[$node->language][] = array(
    'value' => $product['document']['info']['contact']['name'],
    'format' => 'plain_text'
  );
  $node->product_contact_email[$node->language][] = array(
    'value' => $product['document']['info']['contact']['email'],
    'format' => 'plain_text'
  );
  $node->product_contact_url[$node->language][] = array(
    'value' => $product['document']['info']['contact']['url'],
    'format' => 'plain_text'
  );
  if (!isset($product['document']['info']['license'])) {
    $product['document']['info']['license'] = array('name' => "", 'url' => "");
  }
  $node->product_license_name[$node->language][] = array(
    'value' => $product['document']['info']['license']['name'],
    'format' => 'plain_text'
  );
  $node->product_license_url[$node->language][] = array(
    'value' => $product['document']['info']['license']['url'],
    'format' => 'plain_text'
  );
  if (!isset($product['document']['info']['termsOfService']) || empty($product['document']['info']['termsOfService'])) {
    $product['document']['info']['termsOfService'] = '';
  }
  $node->product_terms_of_service[$node->language][] = array(
    'value' => $product['document']['info']['termsOfService'],
    'format' => 'plain_text'
  );
  if (isset($product['visibility'])) {
    $node->product_visibility[$node->language][] = array(
      'value' => serialize($product['visibility']),
      'format' => 'plain_text'
    );
  }
  if (isset($product['visibility']['view']['type']) && mb_strtolower($product['visibility']['view']['type']) == 'public') {
    $node->product_visibility_public[$node->language][] = array('value' => 1);
  }
  else {
    $node->product_visibility_public[$node->language][] = array('value' => 0);
  }
  if (isset($product['visibility']['view']['enabled']) && $product['visibility']['view']['enabled'] == TRUE) {
    $node->product_view_enabled[$node->language][] = array('value' => 1);
  }
  else {
    $node->product_view_enabled[$node->language][] = array('value' => 0);
  }
  if (isset($product['visibility']['subscribe']['enabled']) && $product['visibility']['subscribe']['enabled'] == TRUE) {
    $node->product_subscribe_enabled[$node->language][] = array('value' => 1);
  }
  else {
    $node->product_subscribe_enabled[$node->language][] = array('value' => 0);
  }
  if (isset($product['visibility']['view']['type']) && mb_strtolower($product['visibility']['view']['type']) == 'authenticated') {
    $node->product_visibility_authenticated[$node->language][] = array('value' => 1);
  }
  else {
    $node->product_visibility_authenticated[$node->language][] = array('value' => 0);
  }
  $node->product_visibility_custom_orgs[$node->language] = array();
  if (isset($product['visibility']['view']['type']) && $product['visibility']['view']['type'] == 'custom' && isset($product['visibility']['view']['orgs'])) {
    foreach ($product['visibility']['view']['orgs'] as $org) {
      $node->product_visibility_custom_orgs[$node->language][] = array(
        'value' => $org,
        'format' => 'plain_text'
      );
    }
  }
  $node->product_visibility_custom_tags[$node->language] = array();
  if (isset($product['visibility']['view']['type']) && $product['visibility']['view']['type'] == 'custom' && isset($product['visibility']['view']['tags'])) {
    foreach ($product['visibility']['view']['tags'] as $tag) {
      $node->product_visibility_custom_tags[$node->language][] = array(
        'value' => $tag,
        'format' => 'plain_text'
      );
    }
  }
  $node->product_url[$node->language][] = array(
    'value' => $product['url'],
    'format' => 'plain_text'
  );
  if (isset($product['document']['apis'])) {
    $node->product_apis[$node->language][] = array(
      'value' => serialize($product['document']['apis']),
      'format' => 'plain_text'
    );
  }
  else {
    $node->product_apis[$node->language][] = array(
      'value' => NULL,
      'format' => 'plain_text'
    );
  }
  if (isset($product['document']['plans'])) {
    // merge in the supersedes info which is outside the product doc
    if (isset($product['plans'])) {
      foreach ($product['plans'] as $key => $plan) {
        if (isset($plan['supersedes']) && isset($product['document']['plans'][$key])) {
          $product['document']['plans'][$key]['supersedes'] = $plan['supersedes'];
        }
        if (isset($plan['superseded-by']) && isset($product['document']['plans'][$key])) {
          $product['document']['plans'][$key]['superseded-by'] = $plan['superseded-by'];
        }
      }
    }
    $node->product_plans[$node->language][] = array(
      'value' => serialize($product['document']['plans']),
      'format' => 'plain_text'
    );
  }
  else {
    $node->product_plans[$node->language][] = array(
      'value' => NULL,
      'format' => 'plain_text'
    );
  }
  $node->product_data[$node->language][] = array(
    'value' => yaml_emit($product['document'], YAML_UTF8_ENCODING),
    'format' => 'plain_text'
  );
  $node = node_submit($node); // Prepare node for saving
  node_save($node);

  // need to trigger save of all apis in order to build up ACL
  if (isset($product['document']['apis']) && !empty($product['document']['apis'])) {
    foreach ($product['document']['apis'] as $prodref) {
      $query = new EntityFieldQuery();
      $query->entityCondition('entity_type', 'node')
        ->entityCondition('bundle', 'api')
        ->propertyCondition('status', 1)
        ->fieldCondition('api_ref', 'value', $prodref['name']);
      $results = $query->execute();
      if (isset($results['node'])) {
        $first = array_shift($results['node']);
        $nid = $first->nid;
        $api = node_load($nid);
        node_save($api);
      }
    }
  }

  if (isset($oldtags)) {
    $currenttags = $node->field_producttags[$node->language];
    if (!is_array($currenttags)) {
      $currenttags = array();
    }
    foreach ($oldtags as $tid) {
      if (isset($tid)) {
        $found = FALSE;
        foreach ($currenttags as $currentvalue) {
          if (isset($currentvalue['tid']) && $currentvalue['tid'] == $tid) {
            $found = TRUE;
          }
        }
        if ($found == FALSE) {
          $currenttags[] = array('tid' => $tid);
        }
      }
    }
    $node->field_producttags[$node->language] = $currenttags;
    node_save($node);
  }

  // Product Categories
  $categories_enabled = variable_get('ibm_apim_allow_categories', 1);
  if (isset($product['document']['info']['categories']) && $categories_enabled == 1) {
    $categories = $product['document']['info']['categories'];
    $tids = api_get_taxonomies_from_categories($categories);
    if (isset($node->field_producttags[$node->language])) {
      $currenttags = $node->field_producttags[$node->language];
    }
    else {
      $currenttags = array();
    }
    if (is_array($tids) && !empty($tids)) {
      foreach ($tids as $tid) {
        if (isset($tid) && is_numeric($tid)) {
          $found = FALSE;
          foreach ($currenttags as $currentvalue) {
            if (isset($currentvalue['tid']) && $currentvalue['tid'] == $tid) {
              $found = TRUE;
            }
          }
          if ($found == FALSE) {
            $currenttags[] = array('tid' => $tid);
          }
        }
      }
      $node->field_producttags[$node->language] = $currenttags;
      node_save($node);
    }
  }

  if (isset($node)) {
    // Calling all modules implementing 'hook_ibm_apim_product_create':
    module_invoke_all('ibm_apim_product_create', $node, $product);
    // invoke rules
    if (module_exists('rules')) {
      $rules_payload = array(
        'product_id' => $node->product_id[$node->language][0]['value'],
        'product_nid' => $node->nid,
        'product_name' => $node->title,
        'product_version' => $node->product_version[$node->language][0]['value'],
        'product_ref' => $node->product_ref[$node->language][0]['value'],
        'product_description' => $node->product_description[$node->language][0]['value'],
        'product_contact_name' => $node->product_contact_name[$node->language][0]['value'],
        'product_contact_email' => $node->product_contact_email[$node->language][0]['value'],
        'product_contact_url' => $node->product_contact_url[$node->language][0]['value']
      );
      // Make sure we do not provide NULL values, as Rules module doesn't like them.
      // @see http://drupal.org/node/1497534
      foreach ($rules_payload as $key => $value) {
        if (is_null($value)) {
          $rules_payload[$key] = '';
        }
      }
      rules_invoke_event('product_publish', $rules_payload['product_id'], $rules_payload['product_nid'], $rules_payload['product_name'], $rules_payload['product_version'], $rules_payload['product_ref'], $rules_payload['product_description'], $rules_payload['product_contact_name'], $rules_payload['product_contact_email'], $rules_payload['product_contact_url']);
    }
  }

  return $node->nid;
}

/**
 * Update an existing Product node
 * Used to update the placeholder node for any new Product details returned by APIm
 *
 * @param $node
 * @param $product
 * @param $event
 * @throws \Exception
 */
function _product_updateExistingProductNode($node, $product, $event = 'bgsync') {
  $hostvariable = variable_get('ibm_apim_host');
  $apim_session = &_ibm_apim_get_apim_session();

  if (isset($product) && isset($product['document']['info']) && isset($product['document']['info']['name']) && isset($product['document']['info']['version'])) {
    if (strlen($product['document']['info']['name'] . ':' . $product['document']['info']['version']) > 254) {
      // if product reference is too long then bomb out
      watchdog('_product_updateExistingProductNode', 'ERROR: The "name:version" for this product is greater than 254 characters: %name %version', array(
        '%name' => $product['document']['info']['name'],
        '%version' => $product['document']['info']['version']
      ), WATCHDOG_ERROR);
      return null;
    }
  }

  $language_list = array_keys(locale_language_list('name', TRUE));
  if (isset($product['document']['info']['x-ibm-languages']['title']) && !empty($product['document']['info']['x-ibm-languages']['title'])) {
    foreach ($product['document']['info']['x-ibm-languages']['title'] as $lang => $lang_array) {
      $lang = _ibm_apim_convert_lang_name_to_drupal($lang);
      // if its one of our locales or the root of one of our locales
      foreach ($language_list as $lang_list_key => $lang_list_value) {
        if ($lang == $lang_list_key || $lang == substr($lang_list_key, 0, count($lang))) {
          $node->title_field[$lang][0]['value'] = ibm_apim_truncate_string($product['document']['info']['x-ibm-languages']['title'][$lang]);
        }
      }
    }
  }

  $node->title = ibm_apim_truncate_string($product['document']['info']['title']);
  // if en wasn't in the x-ibm-languages list then assume it was the root level one
  if (!isset($product['document']['info']['x-ibm-languages']['title']) || !in_array('en', array_keys($product['document']['info']['x-ibm-languages']['title']))) {
    $node->title_field['en'][0]['value'] = ibm_apim_truncate_string($product['document']['info']['title']);
    $node->title_field['und'][0]['value'] = ibm_apim_truncate_string($product['document']['info']['title']);
  }
  $node->product_apimhostname[$node->language][0]['value'] = $hostvariable;
  $node->product_providerid[$node->language][0]['value'] = $apim_session['org'];
  $node->product_environmentid[$node->language][0]['value'] = $apim_session['env'];
  $node->product_id[$node->language][0]['value'] = $product['id'];
  $node->product_state[$node->language][0]['value'] = mb_strtolower($product['state']);
  $node->product_ref[$node->language][0]['value'] = $product['document']['info']['name'] . ':' . $product['document']['info']['version'];
  $node->product_name[$node->language][0]['value'] = $product['document']['info']['name'];
  $node->product_version[$node->language][0]['value'] = $product['document']['info']['version'];
  // ensure description is at least set to empty string
  if (!isset($product['document']['info']['description']) || empty($product['document']['info']['description'])) {
    $product['document']['info']['description'] = '';
  }
  if (isset($product['document']['info']['x-ibm-languages']['description']) && !empty($product['document']['info']['x-ibm-languages']['description'])) {
    foreach ($product['document']['info']['x-ibm-languages']['description'] as $lang => $lang_array) {
      $lang = _ibm_apim_convert_lang_name_to_drupal($lang);
      // if its one of our locales or the root of one of our locales
      foreach ($language_list as $lang_list_key => $lang_list_value) {
        if ($lang == $lang_list_key || $lang == substr($lang_list_key, 0, count($lang))) {
          if (!isset($product['document']['info']['x-ibm-languages']['description'][$lang]) || empty($product['document']['info']['x-ibm-languages']['description'][$lang])) {
            $product['document']['info']['x-ibm-languages']['description'][$lang] = '';
          }
          $node->product_description[$lang][0]['value'] = $product['document']['info']['x-ibm-languages']['description'][$lang];
        }
      }
    }
    // if en wasn't in the x-ibm-languages list then assume it was the root level one
    if (!in_array('en', array_keys($product['document']['info']['x-ibm-languages']['description']))) {
      $node->product_description['en'][0]['value'] = $product['document']['info']['description'];
      $node->product_description['und'][0]['value'] = $product['document']['info']['description'];
    }
  }
  else {
    $node->product_description[$node->language][0]['value'] = $product['document']['info']['description'];
  }
  if (!isset($product['document']['info']['contact'])) {
    $product['document']['info']['contact'] = array(
      'name' => "",
      'email' => "",
      'url' => ""
    );
  }
  if (!isset($product['document']['info']['contact']['name'])) {
    $product['document']['info']['contact']['name'] = "";
  }
  if (!isset($product['document']['info']['contact']['email'])) {
    $product['document']['info']['contact']['email'] = "";
  }
  if (!isset($product['document']['info']['contact']['url'])) {
    $product['document']['info']['contact']['url'] = "";
  }
  $node->product_contact_name[$node->language][0]['value'] = $product['document']['info']['contact']['name'];
  $node->product_contact_email[$node->language][0]['value'] = $product['document']['info']['contact']['email'];
  $node->product_contact_url[$node->language][0]['value'] = $product['document']['info']['contact']['url'];
  if (!isset($product['document']['info']['license'])) {
    $product['document']['info']['license'] = array(
      'name' => "",
      'url' => ""
    );
  }
  $node->product_license_name[$node->language][0]['value'] = $product['document']['info']['license']['name'];
  $node->product_license_url[$node->language][0]['value'] = $product['document']['info']['license']['url'];
  if (!isset($product['document']['info']['termsOfService']) || empty($product['document']['info']['termsOfService'])) {
    $product['document']['info']['termsOfService'] = '';
  }
  $node->product_terms_of_service[$node->language][0]['value'] = $product['document']['info']['termsOfService'];
  if (isset($product['visibility'])) {
    $node->product_visibility[$node->language][0]['value'] = serialize($product['visibility']);
  }
  if (isset($product['visibility']['view']['enabled']) && $product['visibility']['view']['enabled'] == TRUE) {
    $node->product_view_enabled[$node->language][0] = array('value' => 1);
  }
  else {
    $node->product_view_enabled[$node->language][0] = array('value' => 0);
  }
  if (isset($product['visibility']['subscribe']['enabled']) && $product['visibility']['subscribe']['enabled'] == TRUE) {
    $node->product_subscribe_enabled[$node->language][0] = array('value' => 1);
  }
  else {
    $node->product_subscribe_enabled[$node->language][0] = array('value' => 0);
  }
  if (isset($product['visibility']['view']['type']) && mb_strtolower($product['visibility']['view']['type']) == 'public') {
    $node->product_visibility_public[$node->language][0]['value'] = 1;
  }
  else {
    $node->product_visibility_public[$node->language][0]['value'] = 0;
  }
  if (isset($product['visibility']['view']['type']) && mb_strtolower($product['visibility']['view']['type']) == 'authenticated') {
    $node->product_visibility_authenticated[$node->language][0]['value'] = 1;
  }
  else {
    $node->product_visibility_authenticated[$node->language][0]['value'] = 0;
  }
  $node->product_visibility_custom_orgs[$node->language] = array();
  if (isset($product['visibility']['view']['type']) && $product['visibility']['view']['type'] == 'custom' && isset($product['visibility']['view']['orgs'])) {
    foreach ($product['visibility']['view']['orgs'] as $org) {
      $node->product_visibility_custom_orgs[$node->language][] = array(
        'value' => $org,
        'format' => 'plain_text'
      );
    }
  }
  $node->product_visibility_custom_tags[$node->language] = array();
  if (isset($product['visibility']['view']['type']) && $product['visibility']['view']['type'] == 'custom' && isset($product['visibility']['view']['tags'])) {
    foreach ($product['visibility']['view']['tags'] as $tag) {
      $node->product_visibility_custom_tags[$node->language][] = array(
        'value' => $tag,
        'format' => 'plain_text'
      );
    }
  }
  $node->product_url[$node->language][0]['value'] = $product['url'];
  if (isset($product['document']['plans'])) {
    // merge in the supersedes info which is outside the product doc
    if (isset($product['plans'])) {
      foreach ($product['plans'] as $key => $plan) {
        if (isset($plan['supersedes']) && isset($product['document']['plans'][$key])) {
          $product['document']['plans'][$key]['supersedes'] = $plan['supersedes'];
        }
        if (isset($plan['superseded-by']) && isset($product['document']['plans'][$key])) {
          $product['document']['plans'][$key]['superseded-by'] = $plan['superseded-by'];
        }
      }
    }
    $node->product_plans[$node->language][0]['value'] = serialize($product['document']['plans']);
  }
  else {
    $node->product_plans[$node->language][0]['value'] = NULL;
  }
  if (isset($product['document']['apis'])) {
    $node->product_apis[$node->language][0]['value'] = serialize($product['document']['apis']);
  }
  else {
    $node->product_apis[$node->language][0]['value'] = NULL;
  }
  $node->product_data[$node->language][0]['value'] = yaml_emit($product['document'], YAML_UTF8_ENCODING);
  node_save($node);

  // need to trigger save of all apis in order to build up ACL
  if (isset($product['document']['apis']) && !empty($product['document']['apis'])) {
    foreach ($product['document']['apis'] as $prodref) {
      $query = new EntityFieldQuery();
      $query->entityCondition('entity_type', 'node')
        ->entityCondition('bundle', 'api')
        ->propertyCondition('status', 1)
        ->fieldCondition('api_ref', 'value', $prodref['name']);
      $results = $query->execute();
      if (isset($results['node'])) {
        $first = array_shift($results['node']);
        $nid = $first->nid;
        $api = node_load($nid);
        node_save($api);
      }
    }
  }

  // Product Categories
  $categories_enabled = variable_get('ibm_apim_allow_categories', 1);
  if (isset($product['document']['info']['categories']) && $categories_enabled == 1) {
    $categories = $product['document']['info']['categories'];
    $tids = api_get_taxonomies_from_categories($categories);
    if (isset($node->field_producttags[$node->language])) {
      $currenttags = $node->field_producttags[$node->language];
    }
    else {
      $currenttags = array();
    }
    if (is_array($tids) && !empty($tids)) {
      foreach ($tids as $tid) {
        if (isset($tid) && is_numeric($tid)) {
          $found = FALSE;
          foreach ($currenttags as $currentvalue) {
            if (isset($currentvalue['tid']) && $currentvalue['tid'] == $tid) {
              $found = TRUE;
            }
          }
          if ($found == FALSE) {
            $currenttags[] = array('tid' => $tid);
          }
        }
      }
      $node->field_producttags[$node->language] = $currenttags;
      node_save($node);
    }
  }

  if (isset($node)) {
    // Calling all modules implementing 'hook_ibm_apim_product_update':
    module_invoke_all('ibm_apim_product_update', $node, $product);
    // invoke rules
    if (module_exists('rules')) {
      $rules_payload = array(
        'product_id' => $node->product_id[$node->language][0]['value'],
        'product_nid' => $node->nid,
        'product_name' => $node->title,
        'product_version' => $node->product_version[$node->language][0]['value'],
        'product_ref' => $node->product_ref[$node->language][0]['value'],
        'product_description' => $node->product_description[$node->language][0]['value'],
        'product_contact_name' => $node->product_contact_name[$node->language][0]['value'],
        'product_contact_email' => $node->product_contact_email[$node->language][0]['value'],
        'product_contact_url' => $node->product_contact_url[$node->language][0]['value']
      );
      // Make sure we do not provide NULL values, as Rules module doesn't like them.
      // @see http://drupal.org/node/1497534
      foreach ($rules_payload as $key => $value) {
        if (is_null($value)) {
          $rules_payload[$key] = '';
        }
      }
      if (isset($event) && _ibm_apim_endsWith($event, 'replace')) {
        rules_invoke_event('product_replace', $rules_payload['product_id'], $rules_payload['product_nid'], $rules_payload['product_name'], $rules_payload['product_version'], $rules_payload['product_ref'], $rules_payload['product_description'], $rules_payload['product_contact_name'], $rules_payload['product_contact_email'], $rules_payload['product_contact_url']);
      }
      else if (isset($event) && _ibm_apim_endsWith($event, 'supersede')) {
        rules_invoke_event('product_supersede', $rules_payload['product_id'], $rules_payload['product_nid'], $rules_payload['product_name'], $rules_payload['product_version'], $rules_payload['product_ref'], $rules_payload['product_description'], $rules_payload['product_contact_name'], $rules_payload['product_contact_email'], $rules_payload['product_contact_url']);
      }
      else if (isset($event) && _ibm_apim_endsWith($event, 'restageFromDraft')) {
        rules_invoke_event('product_restage', $rules_payload['product_id'], $rules_payload['product_nid'], $rules_payload['product_name'], $rules_payload['product_version'], $rules_payload['product_ref'], $rules_payload['product_description'], $rules_payload['product_contact_name'], $rules_payload['product_contact_email'], $rules_payload['product_contact_url']);
      }
      else if (isset($event) && _ibm_apim_endsWith($event, 'deprecate')) {
        rules_invoke_event('product_deprecate', $rules_payload['product_id'], $rules_payload['product_nid'], $rules_payload['product_name'], $rules_payload['product_version'], $rules_payload['product_ref'], $rules_payload['product_description'], $rules_payload['product_contact_name'], $rules_payload['product_contact_email'], $rules_payload['product_contact_url']);
      }
      else if (!isset($event) || _ibm_apim_endsWith($event, 'update')) {
        rules_invoke_event('product_update', $rules_payload['product_id'], $rules_payload['product_nid'], $rules_payload['product_name'], $rules_payload['product_version'], $rules_payload['product_ref'], $rules_payload['product_description'], $rules_payload['product_contact_name'], $rules_payload['product_contact_email'], $rules_payload['product_contact_url']);
      }
    }
  }
}

/**
 * return the nids of the apis in this product
 * @param $productnid
 * @return array
 */
function product_get_apis($productnid) {
  $productnode = node_load($productnid);
  $product_yaml = yaml_parse($productnode->product_data[$productnode->language][0]['value']);
  $api_nids = array();
  if (isset($product_yaml) && is_array($product_yaml['apis'])) {
    foreach ($product_yaml['apis'] as $apiref) {
      // find the api matching this ref
      $query = new EntityFieldQuery();
      $query->entityCondition('entity_type', 'node')
        ->entityCondition('bundle', 'api')
        ->fieldCondition('api_ref', 'value', $apiref['name'])
        ->pager(0); // intentionally disable paging on this request
      $results = $query->execute();
      if (isset($results['node'])) {
        $first = array_shift($results['node']);
        $api_nids[] = $first->nid;
      }
    }
  }
  return $api_nids;
}

/**
 * Implements hook_preprocess_node().
 *
 * @param $variables
 */
function product_preprocess_node(&$variables) {
  global $user;
  if ($variables['node']->type == 'product' && $variables['view_mode'] == 'teaser') {
    $variables['theme_hook_suggestions'][] = 'node__product__teaser';
  }
  if ($variables['node']->type == 'product' && $variables['view_mode'] == 'search_result') {
    $variables['theme_hook_suggestions'][] = 'node__product__search_result';
  }
  if ($variables['node']->type == 'product') {
    $variables['customfields'] = _product_get_custom_fields();
    $product_yaml = yaml_parse($variables['product_data'][0]['value']);
    $variables['product'] = $product_yaml;
    $api_nids = array();
    if (isset($product_yaml) && is_array($product_yaml['apis'])) {
      foreach ($product_yaml['apis'] as $apiref) {
        // find the api matching this ref
        $query = new EntityFieldQuery();
        $query->entityCondition('entity_type', 'node')
          ->entityCondition('bundle', 'api')
          ->fieldCondition('api_ref', 'value', $apiref['name'])
          ->pager(0); // intentionally disable paging on this request
        $results = $query->execute();
        if (isset($results['node'])) {
          $first = array_shift($results['node']);
          $api_nids[] = $first->nid;
        }
      }
    }

    if (isset($api_nids) && is_array($api_nids) && count($api_nids) > 0) {
      $nodes = node_load_multiple($api_nids);
      $variables['apinodes'] = $nodes;
      $cnt = count($api_nids);
      $apicount = '<span class="apicount">(' . t('@count @API included', array(
          '@count' => $cnt,
          '@API' => format_plural($cnt, 'API', 'APIs')
        )) . ')</span>';
    }
    else {
      $variables['apinodes'] = array();
      $apicount = '';
    }

    $showversion = variable_get('ibm_apim_show_versions', 1);
    $versiontext = '';
    if ($showversion == 1) {
      $versiontext = '(' . $variables['product_version'][0]['safe_value'] . ')';
    }
    $variables['titlelink'] = '<span class="apimTitle"> <a href="' . url('product/' . $variables['product_id'][0]['safe_value']) . '">' . $variables['title'] . ' ' . $versiontext . '</a></span>' . $apicount;

    if ($variables['view_mode'] == 'full') {
      $variables['apis'] = array();
      $variables['expandedapis'] = array();
      foreach ($variables['apinodes'] as $key => $api) {
        $swagger = unserialize($api->api_resources[$api->language][0]['value']);
        $variables['apis'][] = $swagger;
        if (isset($api->api_expandedschema[$api->language][0]['value'])) {
          $expandedswagger = unserialize($api->api_expandedschema[$api->language][0]['value']);
          if (isset($expandedswagger)) {
            $variables['expandedapis'][] = $expandedswagger;
          }
        }
      }
      $variables['plans'] = unserialize($variables['product_plans'][0]['value']);

      // build array of info needed to show plan content
      // done here to keep the template cleaner
      $planarray = array();
      foreach ($variables['plans'] as $planname => $plan) {
        $planid = $variables['product_name'][0]['safe_value'] . ':' . $variables['product_version'][0]['safe_value'] . ':' . $planname;
        $planarray[$planid] = product_process_plan($product_yaml, $planid, $plan, $variables['apinodes']);
        if (isset($plan['deploymentState'])) {
          $planarray[$planid]['deploymentState'] = $plan['deploymentState'];
        }
        if (isset($plan['supersedes'])) {
          $planarray[$planid]['supersedes'] = $plan['supersedes'];
        }
        if (isset($plan['superseded-by'])) {
          $planarray[$planid]['superseded-by'] = $plan['superseded-by'];
        }
      }
      $variables['planarray'] = $planarray;
      $variables['subscribable'] = product_check_product_subscribe($variables['node']);

      if (user_is_logged_in() && $user->uid != 1) {
        $query = new EntityFieldQuery();
        $query->entityCondition('entity_type', 'node')
          ->entityCondition('bundle', 'application')
          ->fieldCondition('application_orgid', 'value', ibm_apim_get_current_developer_org()['id']);
        $results = $query->execute();
        if (isset($results['node'])) {
          $nids = array();
          foreach ($results['node'] as $item) {
            $nids[] = $item->nid;
          }
          $variables['apps'] = node_load_multiple($nids);
        }
      }
      else {
        $variables['apps'] = array();
      }
      $docpages = product_get_linked_pages($variables['node']->nid);
      $variables['docpages'] = $docpages;
    }
  }
}

/**
 * Convert the programmatic rate limit into a translatable nicely formatted form
 * @param $value
 * @return null|string
 */
function product_parse_rate_limit($value) {
  if (isset($value)) {
    if (mb_strtolower($value) == 'unlimited') {
      return t('unlimited');
    }
    $parts = explode('/', $value);
    $quantity = $parts[0];
    $timeperiod = $parts[1];
    preg_match("~^(\d+)~", $timeperiod, $m);
    if (isset($m[1])) {
      $periodcount = $m[1];
    }
    if (!isset($periodcount)) {
      $periodcount = 1;
    }
    $period = trim(str_replace($periodcount, "", $timeperiod, $i));

    switch ($period) {
      case 'second' :
        if ($periodcount == 1) {
          return t('@quantity per second', array('@quantity' => $quantity));
        }
        else {
          return t('@quantity per @periodcount seconds', array(
            '@quantity' => $quantity,
            '@periodcount' => $periodcount
          ));
        }
        break;
      case 'minute':
        if ($periodcount == 1) {
          return t('@quantity per minute', array('@quantity' => $quantity));
        }
        else {
          return t('@quantity per @periodcount minutes', array(
            '@quantity' => $quantity,
            '@periodcount' => $periodcount
          ));
        }
        break;
      case 'hour':
        if ($periodcount == 1) {
          return t('@quantity per hour', array('@quantity' => $quantity));
        }
        else {
          return t('@quantity per @periodcount hours', array(
            '@quantity' => $quantity,
            '@periodcount' => $periodcount
          ));
        }
        break;
      case 'day':
        if ($periodcount == 1) {
          return t('@quantity per day', array('@quantity' => $quantity));
        }
        else {
          return t('@quantity per @periodcount days', array(
            '@quantity' => $quantity,
            '@periodcount' => $periodcount
          ));
        }
        break;
      case 'week':
        if ($periodcount == 1) {
          return t('@quantity per week', array('@quantity' => $quantity));
        }
        else {
          return t('@quantity per @periodcount weeks', array(
            '@quantity' => $quantity,
            '@periodcount' => $periodcount
          ));
        }
        break;
    }
  }

  return NULL;
}

/**
 * Given a billing object it returns a display string for that price plan
 *
 * @param array $billing
 * @return string
 */
function product_parse_billing($billing = array()) {
  $text = t("Free");
  if (isset($billing['model'])) {
    if (isset($billing['currency']) && $billing['currency'] != 'JPY') {
      $billing['amount'] = $billing['amount'] / 100;
    }

    if ($billing['model'] === 'flat-fee') {
      $text = $billing['amount'] . ' ' . strtoupper($billing['currency']);
    }
    else if ($billing['model'] === 'stripe_monthly_fixed') {
      $text = t('%length per month', array('%length' => $billing['amount'] . ' ' . strtoupper($billing['currency'])));
      if ($billing['trial-period-days']) {
        $text .= ' ' . format_plural($billing['trial-period-days'], '(%length day trial period)', '(%length days trial period)', array('%length' => $billing['trial-period-days']));
      }
    }
    else if ($billing['model'] === 'flat-calls') {
      $text = t('%length per API call per month', array('%length' => $billing['amount'] . ' ' . strtoupper($billing['currency'])));
      if ($billing['freemium'] && $billing['freeCalls']) {
        $text .= ' ' . format_plural($billing['freeCalls'], '(%length call free per month)', '(%length calls free per month)', array('%length' => $billing['freeCalls']));
      }
    }
    else if ($billing['model'] === 'credits') {
      $text .= format_plural($billing['credits'], '%price for %quantity API Call Credit', '%price for %quantity API Call Credits', array(
        '%price' => $billing['amount'] . ' ' . strtoupper($billing['currency']),
        '%quantity' => $billing['credits']
      ));
    }
  }
  return $text;
}

/**
 * @param $product_yaml
 * @param $planid
 * @param $plan
 * @param $apinodes
 * @return array
 */
function product_process_plan($product_yaml, $planid, $plan, $apinodes) {
  $planarray = array();
  $planarray['nodes'] = array();
  $planarray['data'] = $plan;
  $planratelimit = product_parse_rate_limit('unlimited');
  if (isset($plan['rate-limits']) || isset($plan['burst-limits'])) {
    $rateLimitCount = 0;
    $burstLimitCount = 0;
    if (isset($plan['rate-limits'])) {
      $rateLimitCount = count($plan['rate-limits']);
    }
    if (isset($plan['burst-limits'])) {
      $burstLimitCount = count($plan['burst-limits']);
    }
    if ($rateLimitCount == 0) {
      // if no rate limits but there is a burst limit then rate limit assumed to be unlimited
      $plan['rate-limits'][] = array('value' => 'unlimited');
      $rateLimitCount = count($plan['rate-limits']);
    }
    if (($rateLimitCount + $burstLimitCount) > 1) {
      $tooltip = array('rates' => array(), 'bursts' => array());
      $tooltip['rateLabel'] = t('Rate limits');
      $tooltip['burstLabel'] = t('Burst limits');
      foreach ($plan['rate-limits'] as $ratename => $ratelimit) {
        $tooltip['rates'][] = product_parse_rate_limit($ratelimit['value']);
      }
      foreach ($plan['burst-limits'] as $ratename => $ratelimit) {
        $tooltip['bursts'][] = product_parse_rate_limit($ratelimit['value']);
      }
      $planratelimit = t('@count rate limits *', array('@count' => $rateLimitCount + $burstLimitCount));
    }
    else {
      if ($rateLimitCount > 0) {
        $planratelimit = product_parse_rate_limit(array_shift($plan['rate-limits'])['value']);
      }
      else {
        $planratelimit = product_parse_rate_limit(array_shift($plan['burst-limits'])['value']);
      }
    }
  }
  elseif (isset($plan['rate-limit']) && isset($plan['rate-limit']['value'])) {
    $planratelimit = product_parse_rate_limit($plan['rate-limit']['value']);
  }
  $planarray['rateLimit'] = $planratelimit;
  if (isset($tooltip)) {
    $planarray['rateData'] = $tooltip;
  }
  if (isset($plan['requiresApproval'])) {
    $planarray['requiresApproval'] = $plan['requiresApproval'];
  }
  else {
    $planarray['requiresApproval'] = FALSE;
  }
  $planarray['planId'] = $planid;
  if (is_array($apinodes) && count($apinodes) > 0) {
    foreach ($apinodes as $apikey => $apinode) {
      $apisafenoderef = drupal_html_class($apinode->api_ref[$apinode->language][0]['safe_value']);
      $planarray['nodes'][$apisafenoderef] = array(
        'context' => $apinode->api_context[$apinode->language][0]['safe_value']
      );
      $planarray['nodes'][$apisafenoderef]['nid'] = $apinode->nid;
      $planarray['nodes'][$apisafenoderef]['enabled'] = FALSE;
      $planarray['nodes'][$apisafenoderef]['title'] = $apinode->title;
      $planarray['nodes'][$apisafenoderef]['protocol'] = $apinode->api_protocol[$apinode->language][0]['safe_value'];
      $planarray['nodes'][$apisafenoderef]['url'] = $apinode->api_url[$apinode->language][0]['safe_value'];
      $planarray['nodes'][$apisafenoderef]['id'] = $apinode->api_apiid[$apinode->language][0]['safe_value'];
      $planarray['nodes'][$apisafenoderef]['version'] = $apinode->api_version[$apinode->language][0]['safe_value'];
      $planarray['nodes'][$apisafenoderef]['resources'] = array();
      $swagger = unserialize($apinode->api_resources[$apinode->language][0]['value']);
      if (isset($swagger)) {
        $paths = $swagger['paths'];
        // build up list of resources
        if (is_array($paths)) {
          foreach ($paths as $pathname => $path) {
            $planarray['nodes'][$apisafenoderef]['resources'][$pathname] = array();
            foreach ($path as $verb => $op) {
              if (in_array(mb_strtoupper($verb), array(
                'PUT',
                'POST',
                'GET',
                'DELETE',
                'OPTIONS',
                'HEAD',
                'PATCH'
              ))) {
                $planarray['nodes'][$apisafenoderef]['resources'][$pathname][mb_strtoupper($verb)] = array('enabled' => FALSE);
                $planarray['nodes'][$apisafenoderef]['resources'][$pathname][mb_strtoupper($verb)]['rateLimit'] = $planratelimit;
                if (isset($op['x-ibm-soap']['soap-action']) && !empty($op['x-ibm-soap']['soap-action'])) {
                  $planarray['nodes'][$apisafenoderef]['resources'][$pathname][mb_strtoupper($verb)]['soap-action'] = $op['x-ibm-soap']['soap-action'];
                }
              }
            }
          }
        }
      }
      // now mark included apis as enabled
      if (isset($plan['apis']) && !empty($plan['apis'])) {
        foreach ($plan['apis'] as $apiname => $planapi) {
          $api = $product_yaml['apis'][$apiname];
          if (isset($api) && drupal_html_class($api['name']) == $apisafenoderef) {
            $planarray['nodes'][$apisafenoderef]['enabled'] = TRUE;
            if (!isset($planarray['nodes'][$apisafenoderef]['resources']) || !is_array($planarray['nodes'][$apisafenoderef]['resources'])) {
              $planarray['nodes'][$apisafenoderef]['resources'] = array();
            }
            if (isset($planapi['operations']) && is_array($planapi['operations'])) {
              foreach ($planapi['operations'] as $resource) {
                if (in_array(mb_strtoupper(mb_strtoupper($resource['operation'])), array(
                  'PUT',
                  'POST',
                  'GET',
                  'DELETE',
                  'OPTIONS',
                  'HEAD',
                  'PATCH'
                ))) {
                  // remove any query param portion of the path
                  $path = mb_strstr($resource['path'], '?', TRUE) ?: $resource['path'];
                  if (!isset($planarray['nodes'][$apisafenoderef]['resources'][$path][mb_strtoupper($resource['operation'])])) {
                    $planarray['nodes'][$apisafenoderef]['resources'][$path][mb_strtoupper($resource['operation'])] = array();
                  }
                  $planarray['nodes'][$apisafenoderef]['resources'][$path][mb_strtoupper($resource['operation'])]['enabled'] = TRUE;
                  // include rate limit info
                  $ratelimit = $planratelimit;
                  if (isset($tooltip)) {
                    $optooltip = $tooltip;
                    unset($optooltip['bursts']);
                  }
                  else {
                    unset($optooltip);
                  }
                  if (isset($resource['rate-limits'])) {
                    if (count($resource['rate-limits']) > 1) {
                      $optooltip = array('rates' => array());
                      $optooltip['rateLabel'] = t('Rate limits');
                      $optooltip['burstLabel'] = t('Burst limits');
                      foreach ($resource['rate-limits'] as $ratename => $ratelimit) {
                        $optooltip['rates'][] = product_parse_rate_limit($ratelimit['value']);
                      }
                      $ratelimit = t('@count rate limits *', array('@count' => count($resource['rate-limits'])));
                    }
                    else {
                      $ratelimit = product_parse_rate_limit(array_shift($resource['rate-limits'])['value']);
                    }
                  }
                  elseif (isset($resource['rate-limit']) && isset($resource['rate-limit']['value'])) {
                    $ratelimit = product_parse_rate_limit($resource['rate-limit']['value']);
                  }
                  elseif (isset($plan['rateLimit']['value'])) {
                    $ratelimit = product_parse_rate_limit($plan['rateLimit']['value']);
                  }
                  $planarray['nodes'][$apisafenoderef]['resources'][$path][mb_strtoupper($resource['operation'])]['rateLimit'] = $ratelimit;
                  if (isset($optooltip)) {
                    $planarray['nodes'][$apisafenoderef]['resources'][$path][mb_strtoupper($resource['operation'])]['rateData'] = $optooltip;
                  }
                  $planarray['nodes'][$apisafenoderef]['resources'][$path][mb_strtoupper($resource['operation'])]['op'] = $resource;
                  if (isset($resource['x-ibm-soap']['soap-action']) && !empty($resource['x-ibm-soap']['soap-action'])) {
                    $pos = strpos($resource['x-ibm-soap']['soap-action'], ':');
                    if ($pos !== FALSE) {
                      $parts = explode(':', $resource['x-ibm-soap']['soap-action']);
                      if (isset($parts[1])) {
                        $planarray['nodes'][$apisafenoderef]['resources'][$path][mb_strtoupper($resource['operation'])]['soap-action'] = $parts[1];
                      }
                      else {
                        $planarray['nodes'][$apisafenoderef]['resources'][$path][mb_strtoupper($resource['operation'])]['soap-action'] = $resource['x-ibm-soap']['soap-action'];
                      }
                    }
                    else {
                      $planarray['nodes'][$apisafenoderef]['resources'][$path][mb_strtoupper($resource['operation'])]['soap-action'] = $resource['x-ibm-soap']['soap-action'];
                    }
                  }
                }
              }
            }
            else {
              //assume all enabled
              foreach ($planarray['nodes'][$apisafenoderef]['resources'] as $pathname => $path) {
                foreach ($path as $verb => $op) {
                  if (in_array(mb_strtoupper($verb), array(
                    'PUT',
                    'POST',
                    'GET',
                    'DELETE',
                    'OPTIONS',
                    'HEAD',
                    'PATCH'
                  ))) {
                    if (!isset($planarray['nodes'][$apisafenoderef]['resources'][$pathname][mb_strtoupper($verb)])) {
                      $planarray['nodes'][$apisafenoderef]['resources'][$pathname][mb_strtoupper($verb)] = array();
                    }
                    $planarray['nodes'][$apisafenoderef]['resources'][$pathname][mb_strtoupper($verb)]['enabled'] = TRUE;
                    $planarray['nodes'][$apisafenoderef]['resources'][$pathname][mb_strtoupper($verb)]['rateLimit'] = $planratelimit;
                    if (isset($tooltip)) {
                      $planarray['nodes'][$apisafenoderef]['resources'][$pathname][mb_strtoupper($verb)]['rateData'] = $tooltip;
                    }
                    $planarray['nodes'][$apisafenoderef]['resources'][$pathname][mb_strtoupper($verb)]['op'] = $op;
                    if (isset($op['soap-action']) && !empty($op['soap-action'])) {
                      $pos = mb_strpos($op['soap-action'], ':');
                      if ($pos !== FALSE) {
                        $parts = explode(':', $op['soap-action']);
                        if (isset($parts[1])) {
                          $planarray['nodes'][$apisafenoderef]['resources'][$pathname][mb_strtoupper($verb)]['soap-action'] = $parts[1];
                        }
                        else {
                          $planarray['nodes'][$apisafenoderef]['resources'][$pathname][mb_strtoupper($verb)]['soap-action'] = $op['soap-action'];
                        }
                      }
                      else {
                        $planarray['nodes'][$apisafenoderef]['resources'][$pathname][mb_strtoupper($verb)]['soap-action'] = $op['soap-action'];
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      else {
        // no $plan['apis'] means all enabled
        $planarray['nodes'][$apisafenoderef]['enabled'] = TRUE;
        foreach ($planarray['nodes'][$apisafenoderef]['resources'] as $pathname => $path) {
          foreach ($path as $verb => $op) {
            if (isset($planarray['nodes'][$apisafenoderef]['resources'][$pathname][mb_strtoupper($verb)])) {
              $planarray['nodes'][$apisafenoderef]['resources'][$pathname][mb_strtoupper($verb)] = array();
            }
            $planarray['nodes'][$apisafenoderef]['resources'][$pathname][mb_strtoupper($verb)]['enabled'] = TRUE;
            $planarray['nodes'][$apisafenoderef]['resources'][$pathname][mb_strtoupper($verb)]['rateLimit'] = $planratelimit;
            if (isset($tooltip)) {
              $planarray['nodes'][$apisafenoderef]['resources'][$pathname][mb_strtoupper($verb)]['rateData'] = $tooltip;
            }
            $planarray['nodes'][$apisafenoderef]['resources'][$pathname][mb_strtoupper($verb)]['op'] = $op;
            if (isset($op['soap-action']) && !empty($op['soap-action'])) {
              $pos = mb_strpos($op['soap-action'], ':');
              if ($pos !== FALSE) {
                $parts = explode(':', $op['soap-action']);
                if (isset($parts[1])) {
                  $planarray['nodes'][$apisafenoderef]['resources'][$pathname][mb_strtoupper($verb)]['soap-action'] = $parts[1];
                }
                else {
                  $planarray['nodes'][$apisafenoderef]['resources'][$pathname][mb_strtoupper($verb)]['soap-action'] = $op['soap-action'];
                }
              }
              else {
                $planarray['nodes'][$apisafenoderef]['resources'][$pathname][mb_strtoupper($verb)]['soap-action'] = $op['soap-action'];
              }
            }
          }
        }
      }
    }
  }
  return $planarray;
}

/**
 * Implements hook_preprocess_search_result
 *
 * @param $variables
 */
function product_preprocess_search_result(&$variables) {
  $node = $variables['result']['node'];
  if ($node->nid && $node->type == 'product') { // if the result is an product node we can load the teaser
    $variables['teaser'] = node_view($node, 'teaser');
  }
}

/**
 * Returns a list of NIDs for product nodes the current user is authorized to see
 * @return array
 */
function product_list_products() {
  $returnnids = array();
  // rely on DB ACL checks to only return valid nodes
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'product')
    ->propertyCondition('status', 1)
    ->addTag('node_access');
  $results = $query->execute();
  if (isset($results['node'])) {
    $nids = array();
    foreach ($results['node'] as $item) {
      $nids[] = $item->nid;
    }
    if (!empty($nids)) {
      $returnnids = array_merge($returnnids, $nids);
    }
  }

  return array_reverse(array_unique($returnnids, SORT_NUMERIC));
}

/**
 * Get all the doc pages that are listed as being linked to a given Product NID
 * @param $apinid
 * @return array
 */
function product_get_linked_pages($apinid) {
  if (node_type_load('page') != FALSE) {
    $finalnids = array();
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', 'page')
      ->fieldCondition('field_all_products', 'value', 1);
    $results = $query->execute();
    if (isset($results) && isset($results['node'])) {
      foreach ($results['node'] as $item) {
        $finalnids[] = $item->nid;
      }
    }
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', 'page')
      ->fieldCondition('field_products', 'target_id', $apinid);
    $results = $query->execute();
    if (isset($results) && isset($results['node'])) {
      foreach ($results['node'] as $item) {
        $finalnids[] = $item->nid;
      }
    }
  }

  return array_unique($finalnids, SORT_NUMERIC);
}

/**
 * @param null $ref
 * @return bool
 */
function product_get_nid_from_ref($ref = NULL) {
  $nid = FALSE;
  if (isset($ref)) {
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', 'product')
      ->fieldCondition('product_ref', 'value', $ref);
    $results = $query->execute();
    if (isset($results['node'])) {
      $first = array_shift($results['node']);
      $nid = $first->nid;
    }
  }
  return $nid;
}

/**
 * Check if we have access to specified product Node
 * @param $node
 * @return bool
 */
function product_check_product_access($node) {
  $found = FALSE;
  $view_enabled = TRUE;
  if (isset($node)) {
    // if view disabled then no one has access
    if (isset($node->product_view_enabled[$node->language][0]) && $node->product_view_enabled[$node->language][0]['value'] != 1) {
      $view_enabled = FALSE;
    }
    $myorg = ibm_apim_get_current_developer_org();
    // allow those with permission to bypass check
    if (ibm_apim_explicit_user_access('edit any product content')) {
      $found = TRUE;
    }
    elseif (isset($myorg['id'])) {
      // if we're subscribed then allowed access
      $query = new EntityFieldQuery();
      $query->entityCondition('entity_type', 'node')
        ->entityCondition('bundle', 'application')
        ->fieldCondition('application_orgid', 'value', $myorg['id']);
      $appresults = $query->execute();
      if (isset($appresults['node'])) {
        $nids = array();
        foreach ($appresults['node'] as $item) {
          $nids[] = $item->nid;
        }
        $nodes = node_load_multiple($nids);
        if ($nodes && isset($node->product_state[$node->language][0]) && $node->product_state[$node->language][0]['value'] == "deprecated") {
          foreach ($nodes as $app) {
            if (isset($app->application_subscriptions[$app->language][0]['value'])) {
              $subs = unserialize($app->application_subscriptions[$app->language][0]['value']);
              if (is_array($subs)) {
                foreach ($subs as $sub) {
                  if (isset($sub['product']) && $sub['product'] == $node->product_ref[$node->language][0]['value']) {
                    $found = TRUE;
                  }
                }
              }
            }
          }
        }
      }
    }
    if ($view_enabled == TRUE) {
      if (isset($node->product_state[$node->language][0]) && $node->product_state[$node->language][0]['value'] == "published") {
        // check public nodes
        if (isset($node->product_visibility_public[$node->language][0]['value']) && $node->product_visibility_public[$node->language][0]['value'] == 1) {
          $found = TRUE;
        }
        elseif (isset($node->product_visibility_authenticated[$node->language][0]['value']) && $node->product_visibility_authenticated[$node->language][0]['value'] == 1 && user_is_logged_in()) {
          $found = TRUE;
        }
        if (isset($node->product_visibility_custom_orgs[$node->language]) && isset($myorg['id'])) {
          foreach ($node->product_visibility_custom_orgs[$node->language] as $customorg) {
            if (isset($customorg['value']) && $customorg['value'] == $myorg['id']) {
              $found = TRUE;
            }
          }
        }
        if (isset($node->product_visibility_custom_tags[$node->language]) && isset($myorg['id'])) {
          $query = new EntityFieldQuery();
          $query->entityCondition('entity_type', 'node')
            ->entityCondition('bundle', 'devorg')
            ->fieldCondition('devorg_id', 'value', $myorg['id']);
          $devorgresults = $query->execute();
          if (isset($devorgresults['node'])) {
            $first = array_shift($devorgresults['node']);
            $devorgnid = $first->nid;
            if (!empty($devorgnid)) {
              $devorg = node_load($devorgnid);
              foreach ($devorg->devorg_tags[$devorg->language] as $devorg_tag) {
                $tags[] = $devorg_tag['value'];
              }
              if (isset($tags) && is_array($tags) && count($tags) > 0) {
                foreach ($node->product_visibility_custom_tags[$node->language] as $customtag) {
                  if (isset($customtag['value']) && in_array($customtag['value'], $tags)) {
                    $found = TRUE;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return $found;
}

/**
 * Check if we have access to subscribe to the specified product Node
 * @param $node
 * @return bool
 */
function product_check_product_subscribe($node) {
  if (isset($node)) {
    // if not logged in return false
    if (!user_is_logged_in()) {
      return FALSE;
    }
    // if not a developer return false
    if (!_ibm_apim_user_is_developer()) {
      return FALSE;
    }
    // if deprecated then no one has access
    if (isset($node->product_state[$node->language][0]['value']) && mb_strtolower($node->product_state[$node->language][0]['value']) == 'deprecated') {
      return FALSE;
    }
    // if subscribe disabled then no one has access
    if (!isset($node->product_subscribe_enabled[$node->language][0]) || $node->product_subscribe_enabled[$node->language][0]['value'] != 1) {
      return FALSE;
    }
    $myorg = ibm_apim_get_current_developer_org();
    $visibility = unserialize($node->product_visibility[$node->language][0]['value']);
    if (isset($visibility)) {
      if (isset($visibility['subscribe']['type']) && mb_strtolower($visibility['subscribe']['type']) == 'public') {
        return TRUE;
      }
      elseif (isset($visibility['subscribe']['type']) && mb_strtolower($visibility['subscribe']['type']) == 'authenticated' && user_is_logged_in()) {
        return TRUE;
      }
      elseif (isset($visibility['subscribe']['type']) && mb_strtolower($visibility['subscribe']['type']) == 'custom' && isset($myorg['id'])) {
        foreach ($visibility['subscribe']['orgs'] as $customorg) {
          if ($customorg == $myorg['id']) {
            return TRUE;
          }
        }
        $query = new EntityFieldQuery();
        $query->entityCondition('entity_type', 'node')
          ->entityCondition('bundle', 'devorg')
          ->fieldCondition('devorg_id', 'value', $myorg['id']);
        $devorgresults = $query->execute();
        if (isset($devorgresults['node'])) {
          $first = array_shift($devorgresults['node']);
          $devorgnid = $first->nid;
          if (!empty($devorgnid)) {
            $devorg = node_load($devorgnid);
            foreach ($devorg->devorg_tags[$devorg->language] as $devorg_tag) {
              $tags[] = $devorg_tag['value'];
            }
            if (isset($tags) && is_array($tags) && count($tags) > 0) {
              foreach ($visibility['subscribe']['tags'] as $customtag) {
                if (isset($customtag) && in_array($customtag, $tags)) {
                  return TRUE;
                }
              }
            }
          }
          else {
            return FALSE;
          }
        }
        else {
          return FALSE;
        }
      }
      else {
        return FALSE;
      }
    }
    else {
      return FALSE;
    }
  }
  else {
    return FALSE;
  }
  return FALSE;
}

/**
 * @param $arg
 * @return mixed
 */
function _product_path_param_to_arg($arg) {
  return $arg;
}

/**
 * returns a list of all our custom fields
 * @return array
 */
function _product_get_ibm_fields() {
  $ibmfields = array(
    'product_apimhostname',
    'product_providerid',
    'product_environmentid',
    'product_id',
    'product_name',
    'product_ref',
    'product_version',
    'product_image',
    'product_description',
    'product_contact_name',
    'product_contact_email',
    'product_contact_url',
    'product_license_name',
    'product_license_url',
    'product_terms_of_service',
    'product_visibility',
    'product_view_enabled',
    'product_subscribe_enabled',
    'product_visibility_public',
    'product_visibility_authenticated',
    'product_visibility_custom_orgs',
    'product_visibility_custom_tags',
    'product_apis',
    'product_plans',
    'product_url',
    'product_data',
    'product_state',
    'product_attachments',
    'field_productrating',
    'field_producttags',
    'title_field'
  );
  return $ibmfields;
}

/**
 * Get the instance info for all our fields
 * @return array
 */
function _product_get_custom_fields() {
  $all_fields = field_info_instances("node", "product");
  $keys = array_keys($all_fields);
  $ibmfields = _product_get_ibm_fields();

  $diff = array_diff($keys, $ibmfields);
  return $diff;
}

/**
 * Wrapper script to update an existing product node
 * @param $product
 */
function product_updateProductNode($product) {
  if (isset($product)) {
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', 'product')
      ->fieldCondition('product_ref', 'value', $product['document']['info']['name'] . ':' . $product['document']['info']['version']);

    $results = $query->execute();

    if (isset($results['node'])) {
      $first = array_shift($results['node']);
      $nid = $first->nid;
      $node = node_load($nid);
      _product_updateExistingProductNode($node, $product);
    }
  }
}

/**
 * Delete the specified product node
 * @param $nid
 * @param $event
 */
function product_deleteProductNode($nid, $event) {
  _ibm_apim_delete_popular_block($nid);
  $node = node_load($nid);
  $rules_payload = array(
    'product_id' => $node->product_id[$node->language][0]['value'],
    'product_nid' => $node->nid,
    'product_name' => $node->title,
    'product_version' => $node->product_version[$node->language][0]['value'],
    'product_ref' => $node->product_ref[$node->language][0]['value'],
    'product_description' => $node->product_description[$node->language][0]['value'],
    'product_contact_name' => $node->product_contact_name[$node->language][0]['value'],
    'product_contact_email' => $node->product_contact_email[$node->language][0]['value'],
    'product_contact_url' => $node->product_contact_url[$node->language][0]['value']
  );
  unset($node);
  node_delete($nid);
  // invoke rules
  if (module_exists('rules')) {
    // Make sure we do not provide NULL values, as Rules module doesn't like them.
    // @see http://drupal.org/node/1497534
    foreach ($rules_payload as $key => $value) {
      if (is_null($value)) {
        $rules_payload[$key] = '';
      }
    }
    if (isset($event) && _ibm_apim_endsWith($event, 'retire')) {
      rules_invoke_event('product_retire', $rules_payload['product_id'], $rules_payload['product_nid'], $rules_payload['product_name'], $rules_payload['product_version'], $rules_payload['product_ref'], $rules_payload['product_description'], $rules_payload['product_contact_name'], $rules_payload['product_contact_email'], $rules_payload['product_contact_url']);
    }
    else if (!isset($event) || _ibm_apim_endsWith($event, 'remove')) {
      rules_invoke_event('product_remove', $rules_payload['product_id'], $rules_payload['product_nid'], $rules_payload['product_name'], $rules_payload['product_version'], $rules_payload['product_ref'], $rules_payload['product_description'], $rules_payload['product_contact_name'], $rules_payload['product_contact_email'], $rules_payload['product_contact_url']);
    }
  }

  watchdog('product_deleteProductNode', 'delete product nid=@prod', array('@prod' => $nid), WATCHDOG_NOTICE);
  // clear caches to ensure people don't get stale data
  $nodeurl = url('node/' . $nid, array('absolute' => TRUE));
  cache_clear_all($nodeurl, 'cache_page');
  $nodeurl = url('product', array('absolute' => TRUE));
  cache_clear_all(url($nodeurl), 'cache_page');
}

/**
 * @return string - product icon for a given name
 *
 * @param $apiName
 * @return string
 */
function product_random_image($apiName) {
  $asInt = 0;
  for ($i = 0; $i < mb_strlen($apiName); $i++) {
    $asInt += ord($apiName[$i]);
  }
  $digit = $asInt % 19;
  if ($digit == 0) {
    $digit = 1;
  }
  $num = str_pad($digit, 2, 0, STR_PAD_LEFT);

  return "product_" . $num . ".png";
}

/**
 * Get subscription owners for a given plan reference ('product:version:plan')
 * To include all plans for a given product then simply specify 'product:version'
 *
 * @param $plan
 * @return array
 */
function product_get_subscribing_owners($plan) {
  return product_get_subscribers($plan, 'owners');
}

/**
 * Get all developer organization members subscribed to a given plan reference ('product:version:plan')
 * To include all plans for a given product then simply specify 'product:version'
 *
 * @param $plan
 * @return array
 */
function product_get_subscribing_members($plan) {
  return product_get_subscribers($plan, 'members');
}

/**
 * Get subscribers for a given plan reference ('product:version:plan')
 * To include all plans for a given product then simply specify 'product:version'
 *
 * @param $plan
 * @param string $type
 * @return array
 */
function product_get_subscribers($plan, $type = 'members') {
  $orgs = array();
  // get subscribed apps
  if (isset($plan)) {
    $parts = explode(':', $plan);
    $product = $parts[0];
    $version = $parts[1];
    $planname = $parts[2];

    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'node')->entityCondition('bundle', 'application');
    $results = $query->execute();
    if (isset($results['node'])) {
      $nids = array_keys($results['node']);
      $nodes = node_load_multiple($nids);
      if (isset($nodes)) {
        foreach ($nodes as $node) {
          $subs = unserialize($node->application_subscriptions[$node->language][0]['value']);
          if (is_array($subs)) {
            foreach ($subs as $sub) {
              if (isset($sub['product']) && $sub['product'] == $product . ':' . $version && (!isset($planname) || (isset($planname) && isset($sub['plan']) && $sub['plan'] == $planname))) {
                $orgs[] = $node->application_orgid[$node->language][0]['value'];
              }
            }
          }
        }
      }
    }
  }
  $recipients = array();
  // get users in those orgs
  if (isset($orgs) && is_array($orgs)) {
    foreach ($orgs as $org) {
      $query = new EntityFieldQuery();
      $query->entityCondition('entity_type', 'node')
        ->entityCondition('bundle', 'devorg')
        ->fieldCondition('devorg_id', 'value', $org);
      $results = $query->execute();
      if (isset($results['node'])) {
        $nids = array_keys($results['node']);
        $nodes = node_load_multiple($nids);
        if (isset($nodes) && is_array($nodes)) {
          foreach ($nodes as $node) {
            $org_recipients = array();
            if ($type == 'members') {
              if (isset($node->devorg_members[$node->language][0]['value'])) {
                $members = unserialize($node->devorg_members[$node->language][0]['value']);
                foreach ($members as $member) {
                  if (isset($member['email'])) {
                    $org_recipients[] = $member['email'];
                  }
                }
              }
            }
            $devorg_owner = $node->devorg_owner[$node->language][0]['value'];
            if (!valid_email_address($devorg_owner)) {
              $account = user_load_by_name($devorg_owner);
              if ($account) {
                $devorg_owner = $account->mail;
              }
            }
            $org_recipients[] = $devorg_owner;
            $recipients[] = implode(',', $org_recipients);
          }
        }
      }
    }
  }
  $recipients = array_unique($recipients);
  return $recipients;
}
